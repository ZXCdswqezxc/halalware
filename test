wait(3)
loadstring(game:HttpGet('https://pastebin.com/raw/gimbTwW1'))() -- ac bypass dont touch
local S = {
    PS = game:GetService('Players'), RS = game:GetService('RunService'), WS = game:GetService('Workspace'),
    UIS = game:GetService('UserInputService'), TS = game:GetService('TweenService'), LS = game:GetService('Lighting'),
    CG = game:GetService('CoreGui'), SG = game:GetService('StarterGui'), SP = game:GetService('StarterPack'),
    SR = game:GetService('StarterPlayer'), RP = game:GetService('ReplicatedStorage'), RF = game:GetService('ReplicatedFirst'),
    SS = game:GetService('SoundService'), TV = game:GetService('TeleportService'), BS = game:GetService('BadgeService'),
    PL = game:GetService('PolicyService'), PF = game:GetService('PathfindingService'), DS = game:GetService('DataStoreService'),
    CH = game:GetService('Chat'), MSG = game:GetService('MessagingService'), FS = game:GetService('FriendService'),
    INS = game:GetService('InsertService'), TM = game:GetService('Teams'), SGv = game:GetService('StarterGear'),
    VR = game:GetService('VRService'), GU = game:GetService('GuiService'), TScr = game:GetService('TextService'),
    DB = game:GetService('Debris'), PH = game:GetService('PhysicsService'), LOC = game:GetService('LocalizationService'),
    TST = game:GetService('TestService'), VS = game:GetService('VoiceChatService'), NS = game:GetService('NotificationService'),
    HS = game:GetService('HttpService'), CS = game:GetService('CollectionService'), CP = game:GetService('ContentProvider'),
    PPS = game:GetService('ProximityPromptService'), TCS = game:GetService('TextChatService'), ES = game:GetService('ExperienceService'),
    PSS = game:GetService('PointsService'), GS = game:GetService('GroupService'), MS = game:GetService('MarketplaceService'),
}

local M = {
    abs = math.abs, floor = math.floor, ceil = math.ceil, sqrt = math.sqrt, clamp = math.clamp,
    min = math.min, max = math.max, atan2 = math.atan2, acos = math.acos, asin = math.asin,
    cos = math.cos, sin = math.sin, tan = math.tan, rad = math.rad, deg = math.deg, random = math.random
}

local T = {
    insert = table.insert, remove = table.remove, sort = table.sort, find = table.find, concat = table.concat
}

local STR = {
    sub = string.sub, gsub = string.gsub, lower = string.lower, upper = string.upper,
    rep = string.rep, split = string.split, fmt = string.format
}

local V3, V2, CF, C3, U2, RP = Vector3, Vector2, CFrame, Color3, UDim2, RaycastParams
local RND, SND, HRT = S.RS.RenderStepped, S.RS.Stepped, S.RS.Heartbeat
local LP = S.PS.LocalPlayer
local Char = LP.Character or LP.CharacterAdded:Wait()
local Body = {
    Hum = Char:FindFirstChildOfClass('Humanoid'),
    HRP = Char:FindFirstChild('HumanoidRootPart'),
    Head = Char:FindFirstChild('Head'),
    Tor = Char:FindFirstChild('Torso') or Char:FindFirstChild('UpperTorso'),
    LA = Char:FindFirstChild('Left Arm') or Char:FindFirstChild('LeftUpperArm'),
    RA = Char:FindFirstChild('Right Arm') or Char:FindFirstChild('RightUpperArm'),
    LL = Char:FindFirstChild('Left Leg') or Char:FindFirstChild('LeftUpperLeg'),
    RL = Char:FindFirstChild('Right Leg') or Char:FindFirstChild('RightUpperLeg'),
}

local Cam, Mse, Bp, Tm, UID, PGui = S.WS.CurrentCamera, LP:GetMouse(), LP:FindFirstChildOfClass('Backpack'), LP.Team, LP.UserId, LP:FindFirstChildOfClass('PlayerGui')

local repo = 'https://raw.githubusercontent.com/violin-suzutsuki/LinoriaLib/main/'
local Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()

local Window = Library:CreateWindow({
    Title = 'Halalware',
    Center = true,
    AutoShow = true,
    TabPadding = 8,
    MenuFadeTime = 0.2
})

local Tabs = {
    Combat = Window:AddTab('Combat'),
    Misc = Window:AddTab('Misc'),
    Visuals = Window:AddTab('Visuals'),
    Player = Window:AddTab('Player'),
    Config = Window:AddTab('Config'),
}

ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)
SaveManager:IgnoreThemeSettings()
local MenuGroup = Tabs.Config:AddLeftGroupbox('Menu')
MenuGroup:AddLabel('Menu bind'):AddKeyPicker('MenuKeybind', {
    Default = 'None',
    NoUI = true,
    Text = 'Menu',
})
Library.ToggleKeybind = Options.MenuKeybind
ThemeManager:ApplyToTab(Tabs.Config)
SaveManager:BuildConfigSection(Tabs.Config)
SaveManager:LoadAutoloadConfig()

-- === HUD Section in Config ===
local HUDGroup = Tabs.Config:AddRightGroupbox('HUD')
HUDGroup:AddToggle('ShowWatermark', {
    Text = 'Watermark',
    Default = false,
    Callback = function(v)
        if v then
            local name = LP and LP.Name or 'Player'
            Library:SetWatermark('halalware.skid | ' .. name)
        else
            Library:SetWatermark('')
        end
    end
})
HUDGroup:AddToggle('ShowKeybinds', {
    Text = 'Keybinds',
    Default = false,
    Callback = function(v)
        if Library.KeybindFrame then
            Library.KeybindFrame.Visible = v
        end
    end
})

local ESPConfig = {
    Enabled = false,
    MaxDistance = 200,
    Box = {
        Enable = true,
        Type = 'Full',
        Font = 'ProggyClean',
        Color = Color3.fromRGB(255, 255, 255),
        Filled = {
            Enable = false,
            Gradient = {
                Enable = true,
                Color = {
                    Start = Color3.fromRGB(255, 255, 255),
                    End = Color3.fromRGB(255, 255, 255),
                },
                Rotation = {
                    Enable = true,
                    Auto = true,
                },
                Transparency = 0.3,
            }
        }
    },
    Text = {
        Enable = true,
        Name = {
            Enable = true,
            Teamcheck = true,
            Color = Color3.fromRGB(255, 255, 255),
        },
        Studs = {
            Enable = true,
            Color = Color3.fromRGB(255, 255, 255),
        },
        Tool = {
            Enable = true,
            Color = Color3.fromRGB(255, 255, 255),
        },
    },
    Bars = {
        Enable = true,
        Health = {
            ShowOutline = false,
            Enable = true,
            Lerp = true,
            Color1 = Color3.fromRGB(255, 255, 255)
        }
    }
}

local ESPGroup = Tabs.Visuals:AddLeftGroupbox('>_<')
ESPGroup:AddToggle('ESPEnabled', {
    Text = 'ESP',
    Default = ESPConfig.Enabled,
    Callback = function(v) ESPConfig.Enabled = v end
})
ESPGroup:AddSlider('ESPMaxDist', {
    Text = 'Max Distance',
    Min = 50, Max = 10000, Default = ESPConfig.MaxDistance,
    Rounding = 0,
    Callback = function(v) ESPConfig.MaxDistance = v end
})
ESPGroup:AddToggle('ESPBox', {
    Text = 'Box',
    Default = ESPConfig.Box.Enable,
    Callback = function(v) ESPConfig.Box.Enable = v end
}):AddColorPicker('ESPBoxColor', {
    Default = ESPConfig.Box.Color,
    Callback = function(v) ESPConfig.Box.Color = v end
})
ESPGroup:AddToggle('ESPBoxFilled', {
    Text = 'Filled',
    Default = ESPConfig.Box.Filled.Enable,
    Callback = function(v) ESPConfig.Box.Filled.Enable = v end
}):AddColorPicker('ESPBoxGradStart', {
    Default = ESPConfig.Box.Filled.Gradient.Color.Start,
    Callback = function(v) ESPConfig.Box.Filled.Gradient.Color.Start = v end
}):AddColorPicker('ESPBoxGradEnd', {
    Default = ESPConfig.Box.Filled.Gradient.Color.End,
    Callback = function(v) ESPConfig.Box.Filled.Gradient.Color.End = v end
})
ESPGroup:AddToggle('ESPBoxGradient', {
    Text = 'Gradient Anim',
    Default = ESPConfig.Box.Filled.Gradient.Enable,
    Callback = function(v) ESPConfig.Box.Filled.Gradient.Enable = v end
})
ESPGroup:AddSlider('ESPBoxGradTrans', {
    Text = 'Grad Transp',
    Min = 0, Max = 1, Default = ESPConfig.Box.Filled.Gradient.Transparency, Rounding = 2,
    Callback = function(v) ESPConfig.Box.Filled.Gradient.Transparency = v end
})
ESPGroup:AddToggle('ESPText', {
    Text = 'Text',
    Default = ESPConfig.Text.Enable,
    Callback = function(v) ESPConfig.Text.Enable = v end
})
ESPGroup:AddToggle('ESPName', {
    Text = 'Name',
    Default = ESPConfig.Text.Name.Enable,
    Callback = function(v) ESPConfig.Text.Name.Enable = v end
}):AddColorPicker('ESPNameColor', {
    Default = ESPConfig.Text.Name.Color,
    Callback = function(v) ESPConfig.Text.Name.Color = v end
})
ESPGroup:AddToggle('ESPStuds', {
    Text = 'Studs',
    Default = ESPConfig.Text.Studs.Enable,
    Callback = function(v) ESPConfig.Text.Studs.Enable = v end
}):AddColorPicker('ESPStudsColor', {
    Default = ESPConfig.Text.Studs.Color,
    Callback = function(v) ESPConfig.Text.Studs.Color = v end
})
ESPGroup:AddToggle('ESPTool', {
    Text = 'Tool',
    Default = ESPConfig.Text.Tool.Enable,
    Callback = function(v) ESPConfig.Text.Tool.Enable = v end
}):AddColorPicker('ESPToolColor', {
    Default = ESPConfig.Text.Tool.Color,
    Callback = function(v) ESPConfig.Text.Tool.Color = v end
})
ESPGroup:AddToggle('ESPHealthbar', {
    Text = 'Healthbar',
    Default = ESPConfig.Bars.Health.Enable,
    Callback = function(v) ESPConfig.Bars.Health.Enable = v end
}):AddColorPicker('ESPHealthbarColor', {
    Default = ESPConfig.Bars.Health.Color1,
    Callback = function(v) ESPConfig.Bars.Health.Color1 = v end
})

-- === Bullet Tracers UI (ENGLISH, SHORT) ===
local BulletTracersGroup = Tabs.Visuals:AddRightGroupbox('>_<')

local BulletTracersConfig = {
    Enabled = false,
    Color1 = C3.new(1,1,1),
    Color2 = C3.new(1,1,1),
    Thickness = 1,
    Texture = "rbxassetid://446111271"
}
local BulletTextures = {
    ["Starhook"] = "rbxassetid://446111271",
    ["Chain"] = "rbxassetid://3029306948",
    ["Lightning"] = "rbxassetid://7216850022",
    ["Beam"] = "rbxassetid://1263079249"
}

local BulletToggle = BulletTracersGroup:AddToggle('BulletTracersEnabled', {
    Text = 'Tracer',
    Default = BulletTracersConfig.Enabled,
    Callback = function(v) BulletTracersConfig.Enabled = v end
})
BulletToggle:AddColorPicker('BulletTracersColor1', {
    Default = BulletTracersConfig.Color1,
    Title = 'C1',
    Callback = function(val) BulletTracersConfig.Color1 = val end
})
BulletToggle:AddColorPicker('BulletTracersColor2', {
    Default = BulletTracersConfig.Color2,
    Title = 'C2',
    Callback = function(val) BulletTracersConfig.Color2 = val end
})
BulletTracersGroup:AddSlider('BulletTracersThickness', {
    Text = 'Thick',
    Default = BulletTracersConfig.Thickness,
    Min = 0.1, Max = 10, Rounding = 1,
    Callback = function(val) BulletTracersConfig.Thickness = val end
})
BulletTracersGroup:AddDropdown('BulletTracersTexture', {
    Text = 'Tex',
    Values = {"Starhook", "Chain", "Lightning", "Beam"},
    Default = 'Starhook',
    Callback = function(val) BulletTracersConfig.Texture = BulletTextures[val] end
})

-- === Bullet Tracers Logic (ONLY) ===
local gS = { t = nil, a = 0, s = false, c = {} }
local gM = {
    [2788229376] = { BN = "BULLET_RAYS", BBN = "GunBeam", BP = "Ignored.Siren.Radius" },
    [71189885129233] = { BN = "BULLET_RAYS", BBN = "GunBeam", BP = "Ignored" },
    [5602055394] = { BN = "BULLET_RAYS", BBN = "GunBeam", BP = "Ignored" },
    [17403265390] = { BN = "Part", BBN = "gb", BP = "" },
    [17403166075] = { BN = "Part", BBN = "gb", BP = "" },
    [18111448661] = { BN = "Part", BBN = "gb", BP = "" },
    [15186202290] = { BN = "Part", BBN = "gb", BP = "" },
    [11143225577] = { BN = "BULLET_RAYS", BBN = "GunBeam", BP = "" },
    [15763494605] = { BN = "BULLET_RAYS", BBN = "GunBeam", BP = "" },
    [15166543806] = { BN = "BULLET_RAYS", BBN = "GunBeam", BP = "" },
    [17897702920] = { BN = "BULLET_RAYS", BBN = "GunBeam", BP = "" },
    [16033173781] = { BN = "BULLET_RAYS", BBN = "GunBeam", BP = "Ignored.Siren.Radius" },
    [7213786345] = { BN = "BULLET_RAYS", BBN = "GunBeam", BP = "Ignored.Siren.Radius" },
    [9825515356] = { BN = "BULLET_RAYS", BBN = "GunBeam", BP = "Ignored" },
    [16859411452] = { BN = "bulletray", BBN = "beam", BP = "Ignored" },
    [14277620939] = { BN = "BULLET_RAYS", BBN = "GunBeam", BP = "Ignored" },
    [0] = { BN = "BULLET_RAYS", BBN = "GunBeam", BP = "Ignored" }
}
local function gP(r, p)
    if p == "" then return r end
    local ps = STR.split(p, ".")
    local c = r
    for _, pt in ipairs(ps) do
        c = c:FindFirstChild(pt)
        if not c then return nil end
    end
    return c
end
local function dG()
    local d = gM[game.PlaceId] or gM[0]
    d.BP = gP(S.WS, d.BP) or S.WS
    return d
end
local function cB(f, t, c1, c2, thickness, texture)
    local p = Instance.new("Part")
    p.Name = "BT"
    p.Parent = S.WS
    p.Size = V3.zero
    p.Massless = true
    p.Transparency = 1
    p.CanCollide = false
    p.Position = f
    p.Anchored = true
    local p0, p1 = Instance.new("Part"), Instance.new("Part")
    for _, pt in ipairs({p0, p1}) do
        pt.Parent = p
        pt.Size = V3.zero
        pt.Massless = true
        pt.Transparency = 1
        pt.CanCollide = false
        pt.Anchored = true
    end
    p0.Position = f
    p1.Position = t
    local a0, a1 = Instance.new("Attachment", p0), Instance.new("Attachment", p1)
    local b = Instance.new("Beam")
    b.Texture = texture
    b.TextureMode = Enum.TextureMode.Wrap
    b.TextureLength = 10
    b.LightEmission = 1
    b.LightInfluence = 1
    b.FaceCamera = true
    b.ZOffset = -1
    b.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 1)})
    b.Color = ColorSequence.new({ColorSequenceKeypoint.new(0, c1), ColorSequenceKeypoint.new(1, c2)})
    b.Attachment0 = a0
    b.Attachment1 = a1
    b.Enabled = true
    b.Width0 = thickness
    b.Width1 = thickness
    b.Parent = p
    task.delay(1, function() p:Destroy() end)
end
local function gG(p)
    if not p.Character then return end
    local t = p.Character:FindFirstChildWhichIsA("Tool")
    if not t then return end
    for _, o in ipairs(t:GetDescendants()) do
        if STR.lower(o.Name):find("ammo") and not STR.lower(o.Name):find("max") and o.ClassName:match("Value$") then
            return { a = o, t = t }
        end
    end
end
local function sGT(p)
    for _, cn in ipairs(gS.c) do cn:Disconnect() end
    gS.c = {}
    if not p.Character then
        table.insert(gS.c, p.CharacterAdded:Connect(function() sGT(p) end))
        return
    end
    local function oG(c, ia)
        if not c:IsA("Tool") then return end
        if ia then
            local g = gG(p)
            if g then
                gS.t = g.t
                gS.a = g.a.Value
                table.insert(gS.c, g.a.Changed:Connect(function(na)
                    if na < gS.a then
                        gS.s = true
                        task.wait()
                        gS.s = false
                    end
                    gS.a = na
                end))
            end
        else
            if c == gS.t then gS.t, gS.a = nil, 0 end
        end
    end
    table.insert(gS.c, p.Character.ChildAdded:Connect(function(c) oG(c, true) end))
    table.insert(gS.c, p.Character.ChildRemoved:Connect(function(c) oG(c, false) end))
    local g = gG(p)
    if g then oG(g.t, true) end
end
local function sE()
    local g = dG()
    if not g.BP then return end
    sGT(LP)
    if not LP.Character then LP.CharacterAdded:Connect(function() sGT(LP) end) end
    g.BP.ChildAdded:Connect(function(o)
        if not gS.s then return end
        if BulletTracersConfig.Enabled and o.Name == g.BN then
            local b = o:WaitForChild(g.BBN, 1)
            if not b then return end
            local sp, ep = o.Position, b.Attachment1.WorldPosition
            b:Destroy()
            cB(
                sp, ep,
                BulletTracersConfig.Color1,
                BulletTracersConfig.Color2,
                BulletTracersConfig.Thickness,
                BulletTracersConfig.Texture
            )
        end
    end)
end
sE()

local ESPCache, ESPConnections = {}, {}
local gui_inset = S.GU:GetGuiInset()

local function make_text(parent, font)
    local d = Instance.new("TextLabel")
    d.Parent = parent
    d.Size = U2.new(0, 4, 0, 4)
    d.BackgroundTransparency = 1
    d.TextColor3 = Color3.fromRGB(255,255,255)
    d.TextStrokeTransparency = 0
    d.TextScaled = false
    d.TextSize = 10
    d.TextStrokeColor3 = Color3.fromRGB(0,0,0)
    d.Font = font or Enum.Font.SourceSans
    return d
end

local function clear_esp(player)
    local cache = ESPCache[player]
    if not cache then return end
    if cache.Box and cache.Box.Full then
        cache.Box.Full.Square.Visible = false
        cache.Box.Full.Outline.Visible = false
        cache.Box.Full.Inline.Visible = false
        if cache.Box.Full.Filled then
            cache.Box.Full.Filled.Visible = false
        end
    end
    if cache.Text then
        if cache.Text.Studs then cache.Text.Studs.Visible = false end
        if cache.Text.Tool then cache.Text.Tool.Visible = false end
        if cache.Text.Name then cache.Text.Name.Visible = false end
    end
    if cache.Bars then
        if cache.Bars.Health and cache.Bars.Health.Frame then
            cache.Bars.Health.Frame.Visible = false
            cache.Bars.Health.Outline.Visible = false
        end
    end
end

local function render_esp(player)
    if not player then return end
    ESPCache[player] = ESPCache[player] or {}
    local cache = ESPCache[player]
    cache.Box = cache.Box or {}
    cache.Bars = cache.Bars or {}
    cache.Text = cache.Text or {}
    cache.Box.Full = cache.Box.Full or {
        Square = Drawing.new("Square"),
        Inline = Drawing.new("Square"),
        Outline = Drawing.new("Square"),
        Filled = Instance.new('Frame', Instance.new('ScreenGui', S.CG))
    }
    local Studs = Instance.new("ScreenGui")
    Studs.Parent = S.CG
    local Name = Instance.new("ScreenGui")
    Name.Parent = S.CG
    local Tool = Instance.new("ScreenGui")
    Tool.Parent = S.CG
    cache.Text.Studs = make_text(Studs)
    cache.Text.Tool = make_text(Tool)
    cache.Text.Name = make_text(Name)
    local healthGui = Instance.new("ScreenGui")
    healthGui.Name = player.Name .. "_HealthBar"
    healthGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    healthGui.Parent = S.CG
    local healthOutline = Instance.new("Frame")
    healthOutline.BackgroundColor3 = Color3.new(0, 0, 0)
    healthOutline.BorderSizePixel = 0
    healthOutline.Name = "Outline"
    healthOutline.Parent = healthGui
    local healthFill = Instance.new("Frame")
    healthFill.BackgroundTransparency = 0
    healthFill.BorderSizePixel = 0
    healthFill.Name = "Fill"
    healthFill.Parent = healthOutline
    healthFill.BackgroundColor3 = ESPConfig.Bars.Health.Color1
    cache.Bars.Health = {
        Gui = healthGui,
        Outline = healthOutline,
        Frame = healthFill
    }
end

local function update_esp(player)
    if not player or not ESPCache[player] then return end
    local character = player.Character
    if not character or not LP.Character then return end
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    local client_root_part = LP.Character:FindFirstChild("HumanoidRootPart")
    local humanoid = character:FindFirstChildWhichIsA("Humanoid")
    if not rootPart or not humanoid or not client_root_part then 
        clear_esp(player)
        return 
    end
    if (client_root_part.Position - rootPart.Position).Magnitude > ESPConfig.MaxDistance or not ESPConfig.Enabled then
        clear_esp(player)
        return
    end
    local hrp2D, onScreen = S.WS.CurrentCamera:WorldToViewportPoint(rootPart.Position)
    local charSize = (S.WS.CurrentCamera:WorldToViewportPoint(rootPart.Position - V3.new(0, 1, 0)).Y - S.WS.CurrentCamera:WorldToViewportPoint(rootPart.Position + V3.new(0, 3, 0)).Y) / 2
    local size = V2.new(M.floor(charSize * 1.5), M.floor(charSize * 3.2)) 
    local position = V2.new(M.floor(hrp2D.X - charSize * 1.5 / 2), M.floor(hrp2D.Y - charSize * 3 / 2))
    local cache = ESPCache[player]
    if not onScreen then
        clear_esp(player)
        return
    end
    if ESPConfig.Box.Enable then
        if ESPConfig.Box.Type == "Full" then
            cache.Box.Full.Square.Visible = true
            cache.Box.Full.Square.Position = position
            cache.Box.Full.Square.Size = size
            cache.Box.Full.Square.Color = ESPConfig.Box.Color
            cache.Box.Full.Square.Thickness = 2
            cache.Box.Full.Square.Filled = false
            cache.Box.Full.Square.ZIndex = 9e9
            cache.Box.Full.Outline.Visible = true
            cache.Box.Full.Outline.Position = position - V2.new(1, 1)
            cache.Box.Full.Outline.Size = size + V2.new(2, 2)
            cache.Box.Full.Outline.Color = Color3.new(0, 0, 0)
            cache.Box.Full.Outline.Thickness = 1
            cache.Box.Full.Inline.Visible = true
            cache.Box.Full.Inline.Position = position + V2.new(1, 1)
            cache.Box.Full.Inline.Size = size - V2.new(2, 2)
            cache.Box.Full.Inline.Color = Color3.new(0, 0, 0)
            cache.Box.Full.Inline.Thickness = 1
            cache.Box.Full.Inline.Filled = false
            if ESPConfig.Box.Filled.Enable and cache.Box.Full.Filled then
                cache.Box.Full.Filled.Position = U2.new(0, position.X, 0, position.Y - S.GU:GetGuiInset().Y)
                cache.Box.Full.Filled.Size = U2.new(0, size.X, 0, size.Y)
                cache.Box.Full.Filled.BackgroundTransparency = ESPConfig.Box.Filled.Gradient.Transparency or 0.5
                cache.Box.Full.Filled.BackgroundColor3 = Color3.new(1, 1, 1)
                cache.Box.Full.Filled.Visible = true
                cache.Box.Full.Filled.ZIndex = -9e9
                local gradient = cache.Box.Full.Filled:FindFirstChild("Gradient") or Instance.new("UIGradient")
                gradient.Name = "Gradient"
                gradient.Color = ColorSequence.new({
                    ColorSequenceKeypoint.new(0, ESPConfig.Box.Filled.Gradient.Color.Start),
                    ColorSequenceKeypoint.new(1, ESPConfig.Box.Filled.Gradient.Color.End)
                })
                if ESPConfig.Box.Filled.Gradient.Enable then
                    gradient.Rotation = math.sin(tick() * 2) * 180
                else
                    gradient.Rotation = 0
                end
                if not gradient.Parent then gradient.Parent = cache.Box.Full.Filled end
            elseif cache.Box.Full.Filled then
                cache.Box.Full.Filled.Visible = false
            end
        else
            cache.Box.Full.Square.Visible = false
            cache.Box.Full.Outline.Visible = false
            cache.Box.Full.Inline.Visible = false
            if cache.Box.Full.Filled then cache.Box.Full.Filled.Visible = false end
        end
    else
        cache.Box.Full.Square.Visible = false
        cache.Box.Full.Outline.Visible = false
        cache.Box.Full.Inline.Visible = false
        if cache.Box.Full.Filled then cache.Box.Full.Filled.Visible = false end
    end
    if ESPConfig.Bars.Health.Enable and humanoid then
        local targetHealth = M.clamp(humanoid.Health / humanoid.MaxHealth, 0, 1)
        local lastHealth = cache.Bars.Health.LastHealth or targetHealth
        local lerpedHealth = lastHealth + (targetHealth - lastHealth) * 0.05
        cache.Bars.Health.LastHealth = lerpedHealth
        local x = position.X - 7
        if cache.Bars.Health.Outline and cache.Bars.Health.Frame then
            cache.Bars.Health.Outline.Visible = true
            cache.Bars.Health.Outline.Position = U2.new(0, x - 1, 0, position.Y - S.GU:GetGuiInset().Y - 1)
            cache.Bars.Health.Outline.Size = U2.new(0, 5, 0, size.Y + 1.1)
            cache.Bars.Health.Outline.BackgroundTransparency = 0.2
            cache.Bars.Health.Frame.Visible = true
            cache.Bars.Health.Frame.Position = U2.new(0, 1, 0, (1 - lerpedHealth) * size.Y + 1)
            cache.Bars.Health.Frame.Size = U2.new(0, 3, 0, lerpedHealth * size.Y)
            cache.Bars.Health.Frame.BackgroundColor3 = ESPConfig.Bars.Health.Color1
        end
    else
        if cache.Bars.Health.Outline then cache.Bars.Health.Outline.Visible = false end
        if cache.Bars.Health.Frame then cache.Bars.Health.Frame.Visible = false end
    end
    if ESPConfig.Text.Enable then
        if cache.Text.Name then
            cache.Text.Name.Visible = ESPConfig.Text.Name.Enable
            if ESPConfig.Text.Name.Enable then
                cache.Text.Name.Position = U2.new(0, position.X + (size.X / 2) - (cache.Text.Name.AbsoluteSize.X / 2), 0, position.Y - S.GU:GetGuiInset().Y - 9)
                cache.Text.Name.Text = player.Name
                cache.Text.Name.TextColor3 = ESPConfig.Text.Name.Color
            end
        end
        if cache.Text.Tool then
            cache.Text.Tool.Visible = ESPConfig.Text.Tool.Enable
            if ESPConfig.Text.Tool.Enable then
                cache.Text.Tool.Position = U2.new(0, position.X + (size.X / 2) - (cache.Text.Tool.AbsoluteSize.X / 2), 0, position.Y - S.GU:GetGuiInset().Y + size.Y + 15)
                local tool = character:FindFirstChildOfClass("Tool")
                cache.Text.Tool.Text = tool and tool.Name or "none"
                cache.Text.Tool.TextColor3 = ESPConfig.Text.Tool.Color
            end
        end
        if cache.Text.Studs then
            cache.Text.Studs.Visible = ESPConfig.Text.Studs.Enable
            if ESPConfig.Text.Studs.Enable then
                cache.Text.Studs.Position = U2.new(0, position.X + (size.X / 2) - (cache.Text.Studs.AbsoluteSize.X / 2), 0, position.Y - S.GU:GetGuiInset().Y + size.Y + 5)
                local meters = (S.WS.CurrentCamera.CFrame.Position - rootPart.Position).Magnitude * 0.28
                cache.Text.Studs.Text = STR.fmt("[%.0fm]", meters)
                cache.Text.Studs.TextColor3 = ESPConfig.Text.Studs.Color
            end
        end
    else
        if cache.Text.Name then cache.Text.Name.Visible = false end
        if cache.Text.Tool then cache.Text.Tool.Visible = false end
        if cache.Text.Studs then cache.Text.Studs.Visible = false end
    end
end

for _, player in ipairs(S.PS:GetPlayers()) do
    if player ~= LP then
        render_esp(player)
    end
end
S.PS.PlayerAdded:Connect(function(player)
    if player ~= LP then
        render_esp(player)
    end
end)
S.PS.PlayerRemoving:Connect(function(player)
    if player ~= LP then
        clear_esp(player)
    end
end)

if ESPConnections.Heartbeat then ESPConnections.Heartbeat:Disconnect() end
ESPConnections.Heartbeat = S.RS.Heartbeat:Connect(function()
    for v, _ in pairs(ESPCache) do
        if v then
            update_esp(v)
        end
    end
end)

local NameESPGroup = Tabs.Visuals:AddRightGroupbox('>_<')
local ShowNameMethodConfig = {
    Mode = 'Display',
}

NameESPGroup:AddDropdown('ShowNameMethod', {
    Values = {'Display', 'Default', 'None'},
    Default = 'Display',
    Multi = false,
    Text = 'ShowNameMethod',
    Callback = function(v) ShowNameMethodConfig.Mode = v end
})

local function UpdateShowNameMethod(player)
    if player == LP then return end
    local char = player.Character
    if not char then return end
    local hum = char:FindFirstChildOfClass('Humanoid')
    if not hum then return end
    if ShowNameMethodConfig.Mode == 'None' then
        hum.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.None
        return
    end
    hum.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.Viewer
    hum.NameOcclusion = Enum.NameOcclusion.NoOcclusion
    hum.DisplayName = (ShowNameMethodConfig.Mode == 'Display' and player.DisplayName ~= '' and player.DisplayName) or player.Name
end

local function UpdateAllShowNameMethod()
    for _, p in ipairs(S.PS:GetPlayers()) do
        UpdateShowNameMethod(p)
    end
end

S.PS.PlayerAdded:Connect(function(p)
    p.CharacterAdded:Connect(function() UpdateShowNameMethod(p) end)
end)
for _, p in ipairs(S.PS:GetPlayers()) do
    if p.Character then UpdateShowNameMethod(p) end
    p.CharacterAdded:Connect(function() UpdateShowNameMethod(p) end)
end
S.RS.Heartbeat:Connect(UpdateAllShowNameMethod)

-- Unlock Camera Distance (Misc)
local originalPlayerMaxZoom = LP.CameraMaxZoomDistance

local MiscCameraGroup = Tabs.Misc:AddLeftGroupbox('>_<')
MiscCameraGroup:AddToggle('UnlockCameraDistance', {
    Text = 'Unlock Camera Distance',
    Default = false,
    Callback = function(v)
        if v then
            -- Включено: ставим максимальную дистанцию камеры на бесконечность для игрока
            LP.CameraMaxZoomDistance = math.huge
        else
            -- Выключено: возвращаем оригинальное значение
            LP.CameraMaxZoomDistance = originalPlayerMaxZoom
        end
    end
})

-- SphereAura UI и логика
local SphereAuraSettings = {
    enabled = false,
    color1 = Color3.new(1, 1, 1),
    color2 = Color3.new(1, 1, 1),
    size = 10,
    lightEmission = 1
}
local currentAura

local function updateAura(prop)
    if not (currentAura and currentAura.Parent) then return end
    local swirl = currentAura:FindFirstChild("Attachment"):FindFirstChild("swirl")
    if not swirl then return end
    if prop == "color" or prop == nil then
        swirl.Color = ColorSequence.new({ColorSequenceKeypoint.new(0, SphereAuraSettings.color1), ColorSequenceKeypoint.new(1, SphereAuraSettings.color2)})
    end
    if prop == "size" or prop == nil then
        swirl.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, SphereAuraSettings.size), NumberSequenceKeypoint.new(1, SphereAuraSettings.size)})
    end
    if prop == "light" or prop == nil then
        swirl.LightEmission = SphereAuraSettings.lightEmission
    end
end

local function removePlayerAura()
    if currentAura and currentAura.Parent then currentAura:Destroy() end
    currentAura = nil
end

local function createPlayerAura(character)
    removePlayerAura()
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart") or character:WaitForChild("HumanoidRootPart", 3)
    if not humanoidRootPart then return end
    local auraBase = Instance.new("Part")
    auraBase.Size, auraBase.Transparency, auraBase.Anchored, auraBase.CanCollide, auraBase.Name, auraBase.Parent = Vector3.new(1, 1, 1), 1, false, false, "AuraBase", S.WS
    local weld = Instance.new("Weld")
    weld.Part0, weld.Part1, weld.C0, weld.Parent = humanoidRootPart, auraBase, CFrame.new(0, 0, 0), auraBase
    local attachment = Instance.new("Attachment")
    attachment.Parent = auraBase
    local swirlEmitter = Instance.new("ParticleEmitter")
    swirlEmitter.Name, swirlEmitter.Texture, swirlEmitter.Lifetime, swirlEmitter.Rate, swirlEmitter.RotSpeed, swirlEmitter.Speed = "swirl", "rbxassetid://10558425570", NumberRange.new(2), 150, NumberRange.new(200), NumberRange.new(0.01)
    swirlEmitter.SpreadAngle, swirlEmitter.VelocitySpread, swirlEmitter.Size, swirlEmitter.Transparency = Vector2.new(-360, 360), -360, NumberSequence.new({NumberSequenceKeypoint.new(0, SphereAuraSettings.size), NumberSequenceKeypoint.new(1, SphereAuraSettings.size)}), NumberSequence.new({NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.5006, 0.5), NumberSequenceKeypoint.new(1, 1)})
    swirlEmitter.Color, swirlEmitter.LightEmission, swirlEmitter.ZOffset, swirlEmitter.Orientation, swirlEmitter.LockedToPart, swirlEmitter.Parent = ColorSequence.new({ColorSequenceKeypoint.new(0, SphereAuraSettings.color1), ColorSequenceKeypoint.new(1, SphereAuraSettings.color2)}), SphereAuraSettings.lightEmission, -1, Enum.ParticleOrientation.VelocityPerpendicular, true, attachment
    currentAura = auraBase
end

local function applyPlayerAura()
    local character = LP.Character
    if not character then
        local characterAddedConnection
        if characterAddedConnection then characterAddedConnection:Disconnect() end
        characterAddedConnection = LP.CharacterAdded:Connect(function(newCharacter)
            if SphereAuraSettings.enabled then createPlayerAura(newCharacter) end
        end)
        return
    end
    createPlayerAura(character)
    if not characterAddedConnection then
        local characterAddedConnection
        characterAddedConnection = LP.CharacterAdded:Connect(function(newCharacter)
            if SphereAuraSettings.enabled then createPlayerAura(newCharacter) end
        end)
    end
end

getgenv().GetSphereAuraSettings = function() return SphereAuraSettings end

local SphereAuraGroup = Tabs.Visuals:AddRightGroupbox('>_<')
SphereAuraGroup:AddToggle('SphereAura', {
    Text = 'SphereAura',
    Default = false,
    Callback = function(v)
        SphereAuraSettings.enabled = v
        if v then
            applyPlayerAura()
        else
            removePlayerAura()
        end
    end
}):AddColorPicker('SphereAuraColor1', {
    Default = SphereAuraSettings.color1,
    Title = 'Color 1',
    Callback = function(val)
        SphereAuraSettings.color1 = val
        updateAura("color")
    end
}):AddColorPicker('SphereAuraColor2', {
    Default = SphereAuraSettings.color2,
    Title = 'Color 2',
    Callback = function(val)
        SphereAuraSettings.color2 = val
        updateAura("color")
    end
})

local SphereAuraSub = SphereAuraGroup:AddDependencyBox()
SphereAuraSub:AddSlider('SphereAuraSize', {
    Text = 'Size',
    Default = SphereAuraSettings.size,
    Min = 1,
    Max = 50,
    Rounding = 1,
    Callback = function(val)
        SphereAuraSettings.size = val
        updateAura("size")
    end
})
SphereAuraSub:AddSlider('SphereAuraLightEmission', {
    Text = 'LightEmission',
    Default = SphereAuraSettings.lightEmission,
    Min = 0,
    Max = 2,
    Rounding = 2,
    Callback = function(val)
        SphereAuraSettings.lightEmission = val
        updateAura("light")
    end
})
SphereAuraSub:SetupDependencies({{Toggles.SphereAura, true}})

-- CircleAura UI и логика
local CircleAuraSettings = {
    enabled = false,
    beamColor = Color3.new(1, 1, 1),
    circleColor = Color3.new(1, 1, 1),
    lightEmission = 0.8,
    circleTexture = "rbxassetid://8920246243"
}
local currentCircleAura

local function removeCircleAura()
    if currentCircleAura and currentCircleAura.Parent then currentCircleAura:Destroy() end
    currentCircleAura = nil
end

local function updateCircleAura(prop)
    if not (currentCircleAura and currentCircleAura.Parent) then return end
    for _, obj in pairs(currentCircleAura:GetDescendants()) do
        if (prop == nil or prop == "beamColor") and obj:IsA("Beam") then
            obj.Color = ColorSequence.new(CircleAuraSettings.beamColor)
        end
        if (prop == nil or prop == "circleColor") and obj:IsA("ParticleEmitter") and obj.Name == "Circle" then
            obj.Color = ColorSequence.new({ColorSequenceKeypoint.new(0, CircleAuraSettings.circleColor), ColorSequenceKeypoint.new(1, CircleAuraSettings.circleColor)})
        end
        if (prop == nil or prop == "lightEmission") and (obj:IsA("Beam") or obj:IsA("ParticleEmitter")) then
            obj.LightEmission = CircleAuraSettings.lightEmission
        end
        if (prop == nil or prop == "circleTexture") and obj:IsA("ParticleEmitter") and obj.Name == "Circle" then
            obj.Texture = CircleAuraSettings.circleTexture
        end
    end
end

local function createCircleAura(character)
    removeCircleAura()
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart") or character:WaitForChild("HumanoidRootPart", 3)
    if not humanoidRootPart then return end
    local auraBase = Instance.new("Part")
    auraBase.Size, auraBase.Transparency, auraBase.Anchored, auraBase.CanCollide, auraBase.Name, auraBase.Parent = Vector3.new(1, 1, 1), 1, true, false, "CircleAuraBase", S.WS
    auraBase.CFrame = CFrame.new(humanoidRootPart.Position) * CFrame.new(0, -0.15, 0)
    local positionUpdateConnection
    positionUpdateConnection = S.RS.Heartbeat:Connect(function()
        if humanoidRootPart and humanoidRootPart.Parent and auraBase and auraBase.Parent then
            auraBase.CFrame = CFrame.new(humanoidRootPart.Position) * CFrame.new(0, -0.15, 0)
        else
            if positionUpdateConnection then positionUpdateConnection:Disconnect() end
        end
    end)
    auraBase.AncestryChanged:Connect(function() if not auraBase.Parent and positionUpdateConnection then positionUpdateConnection:Disconnect() end end)

    local mainAttachment = Instance.new("Attachment")
    mainAttachment.Name, mainAttachment.Position, mainAttachment.Parent = "Main", Vector3.new(0, -2.75, 0), auraBase
    local circleEmitter = Instance.new("ParticleEmitter")
    circleEmitter.Name, circleEmitter.Texture, circleEmitter.Lifetime, circleEmitter.Rate, circleEmitter.RotSpeed, circleEmitter.Speed = "Circle", CircleAuraSettings.circleTexture, NumberRange.new(9), 0.333, NumberRange.new(120), NumberRange.new(0.001)
    circleEmitter.Size, circleEmitter.Transparency, circleEmitter.Color, circleEmitter.LightEmission, circleEmitter.ZOffset, circleEmitter.Orientation, circleEmitter.LockedToPart, circleEmitter.Parent = NumberSequence.new({NumberSequenceKeypoint.new(0, 3), NumberSequenceKeypoint.new(1, 3)}), NumberSequence.new({NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.1, 0), NumberSequenceKeypoint.new(0.5, 0), NumberSequenceKeypoint.new(0.6256, 0.0875), NumberSequenceKeypoint.new(0.7691, 0.3875), NumberSequenceKeypoint.new(0.8677, 0.7125), NumberSequenceKeypoint.new(0.9230, 0.875), NumberSequenceKeypoint.new(0.9552, 0.9375), NumberSequenceKeypoint.new(1, 0.975)}), ColorSequence.new({ColorSequenceKeypoint.new(0, CircleAuraSettings.circleColor), ColorSequenceKeypoint.new(1, CircleAuraSettings.circleColor)}), CircleAuraSettings.lightEmission, 0.05, Enum.ParticleOrientation.VelocityPerpendicular, true, mainAttachment

    local attachOne, attachTwo = Instance.new("Attachment"), Instance.new("Attachment")
    attachOne.Name, attachOne.Position, attachOne.Parent = "One", Vector3.new(0, -2.8, 2.6), auraBase
    attachTwo.Name, attachTwo.Position, attachTwo.Parent = "Two", Vector3.new(0, -2.8, -2.6), auraBase
    local beamOne = Instance.new("Beam")
    beamOne.Name, beamOne.Texture, beamOne.TextureSpeed, beamOne.TextureLength, beamOne.Width0, beamOne.Width1, beamOne.CurveSize0, beamOne.CurveSize1, beamOne.Segments, beamOne.LightEmission, beamOne.Transparency, beamOne.Color, beamOne.Attachment0, beamOne.Attachment1, beamOne.Parent = "One", "rbxassetid://8920073892", -0.3, 0.5, 4, 4, -3.5, 3.5, 25, CircleAuraSettings.lightEmission, NumberSequence.new({NumberSequenceKeypoint.new(0, 0.3), NumberSequenceKeypoint.new(1, 0.3)}), ColorSequence.new(CircleAuraSettings.beamColor), attachOne, attachTwo, auraBase
    local beamTwo = Instance.new("Beam")
    beamTwo.Name, beamTwo.Texture, beamTwo.TextureSpeed, beamTwo.TextureLength, beamTwo.Width0, beamTwo.Width1, beamTwo.CurveSize0, beamTwo.CurveSize1, beamTwo.Segments, beamTwo.LightEmission, beamTwo.Transparency, beamTwo.Color, beamTwo.Attachment0, beamTwo.Attachment1, beamTwo.Parent = "Two", "rbxassetid://8920073892", 0.3, 0.5, 4, 4, 3.5, -3.5, 25, CircleAuraSettings.lightEmission, NumberSequence.new({NumberSequenceKeypoint.new(0, 0.3), NumberSequenceKeypoint.new(1, 0.3)}), ColorSequence.new(CircleAuraSettings.beamColor), attachOne, attachTwo, auraBase

    local attachThree, attachFour = Instance.new("Attachment"), Instance.new("Attachment")
    attachThree.Name, attachThree.Position, attachThree.Parent = "Three", Vector3.new(0, -2.7, 0), auraBase
    attachFour.Name, attachFour.Position, attachFour.Parent = "Four", Vector3.new(0, 6, 0), auraBase
    local beamThree = Instance.new("Beam")
    beamThree.Name, beamThree.Texture, beamThree.TextureSpeed, beamThree.TextureLength, beamThree.Width0, beamThree.Width1, beamThree.Segments, beamThree.LightEmission, beamThree.Transparency, beamThree.Color, beamThree.FaceCamera, beamThree.Attachment0, beamThree.Attachment1, beamThree.Parent = "Three", "rbxassetid://9020147050", 0.3, 0.1, 5, 6, 5, CircleAuraSettings.lightEmission, NumberSequence.new({NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.1, 1), NumberSequenceKeypoint.new(0.4, 0.4), NumberSequenceKeypoint.new(1, 1)}), ColorSequence.new(CircleAuraSettings.beamColor), true, attachThree, attachFour, auraBase
    local beamFour = Instance.new("Beam")
    beamFour.Name, beamFour.Texture, beamFour.TextureSpeed, beamFour.TextureLength, beamFour.Width0, beamFour.Width1, beamFour.Segments, beamFour.LightEmission, beamFour.Transparency, beamFour.Color, beamFour.FaceCamera, beamFour.Attachment0, beamFour.Attachment1, beamFour.Parent = "Four", "rbxassetid://8984452855", 0.06, 0.4, 5, 6, 5, CircleAuraSettings.lightEmission, NumberSequence.new({NumberSequenceKeypoint.new(0, 0.3), NumberSequenceKeypoint.new(1, 1)}), ColorSequence.new(CircleAuraSettings.beamColor), true, attachThree, attachFour, auraBase
    local beamFive = Instance.new("Beam")
    beamFive.Name, beamFive.Texture, beamFive.TextureSpeed, beamFive.TextureLength, beamFive.Width0, beamFive.Width1, beamFive.Segments, beamFive.LightEmission, beamFive.Transparency, beamFive.Color, beamFive.FaceCamera, beamFive.Attachment0, beamFive.Attachment1, beamFive.Parent = "Five", "http://www.roblox.com/asset/?id=4390493166", 0.2, 0.15, 4, 4, 5, CircleAuraSettings.lightEmission, NumberSequence.new({NumberSequenceKeypoint.new(0, 0.3), NumberSequenceKeypoint.new(1, 1)}), ColorSequence.new(CircleAuraSettings.beamColor), true, attachThree, attachFour, auraBase

    currentCircleAura = auraBase
end

local function applyCircleAura()
    local character = LP.Character
    if not character then
        local circleAuraConnection
        if circleAuraConnection then circleAuraConnection:Disconnect() end
        circleAuraConnection = LP.CharacterAdded:Connect(function(newCharacter)
            if CircleAuraSettings.enabled then createCircleAura(newCharacter) end
        end)
        return
    end
    createCircleAura(character)
    if not circleAuraConnection then
        local circleAuraConnection
        circleAuraConnection = LP.CharacterAdded:Connect(function(newCharacter)
            if CircleAuraSettings.enabled then createCircleAura(newCharacter) end
        end)
    end
end

getgenv().GetCircleAuraSettings = function() return CircleAuraSettings end

-- UI
SphereAuraGroup:AddToggle('CircleAura', {
    Text = 'CircleAura',
    Default = false,
    Callback = function(v)
        CircleAuraSettings.enabled = v
        if v then
            applyCircleAura()
        else
            removeCircleAura()
        end
    end
}):AddColorPicker('CircleAuraBeamColor', {
    Default = CircleAuraSettings.beamColor,
    Title = 'Beam Color',
    Callback = function(val)
        CircleAuraSettings.beamColor = val
        updateCircleAura('beamColor')
    end
}):AddColorPicker('CircleAuraCircleColor', {
    Default = CircleAuraSettings.circleColor,
    Title = 'Circle Color',
    Callback = function(val)
        CircleAuraSettings.circleColor = val
        updateCircleAura('circleColor')
    end
})

local CircleAuraSub = SphereAuraGroup:AddDependencyBox()
CircleAuraSub:AddSlider('CircleAuraLightEmission', {
    Text = 'LightEmission',
    Default = CircleAuraSettings.lightEmission,
    Min = 0,
    Max = 2,
    Rounding = 2,
    Callback = function(val)
        CircleAuraSettings.lightEmission = val
        updateCircleAura('lightEmission')
    end
})
CircleAuraSub:AddDropdown('CircleAuraCircleTexture', {
    Text = 'Circle Texture',
    Values = {
        '8920246243',
        '10365549270',
        '5726444189',
        '1266170131',
        '12363692255',
        '12363692920',
    },
    Default = '8920246243',
    Callback = function(val)
        CircleAuraSettings.circleTexture = 'rbxassetid://' .. val
        updateCircleAura('circleTexture')
    end
})
CircleAuraSub:SetupDependencies({{Toggles.CircleAura, true}})

-- ChinaHat UI и логика
local ChinaHatSettings = {
    enabled = false,
    minCameraDistance = 1,
    hatTransparency = 0.35,
    circleTransparency = 1,
    height = 0.75,
    radius = 5,
    sides = 25,
    rainbow = false,
    color = Color3.fromRGB(255, 255, 255),
    offset = Vector3.new(0, 0.75, 0)
}

local ChinaHatGroup = Tabs.Visuals:AddLeftGroupbox('>_<')
ChinaHatGroup:AddToggle('ChinaHatEnabled', {
    Text = 'ChinaHat',
    Default = ChinaHatSettings.enabled,
    Callback = function(v)
        ChinaHatSettings.enabled = v
    end
}):AddColorPicker('ChinaHatColor', {
    Default = ChinaHatSettings.color,
    Title = 'Color',
    Callback = function(val)
        ChinaHatSettings.color = val
    end
})
ChinaHatGroup:AddSlider('ChinaHatHeight', {
    Text = 'Height',
    Default = ChinaHatSettings.height,
    Min = 0.1,
    Max = 3,
    Rounding = 2,
    Callback = function(val)
        ChinaHatSettings.height = val
    end
})
ChinaHatGroup:AddSlider('ChinaHatRadius', {
    Text = 'Radius',
    Default = ChinaHatSettings.radius,
    Min = 1,
    Max = 10,
    Rounding = 2,
    Callback = function(val)
        ChinaHatSettings.radius = val
    end
})
ChinaHatGroup:AddToggle('ChinaHatRainbow', {
    Text = 'Rainbow',
    Default = ChinaHatSettings.rainbow,
    Callback = function(v)
        ChinaHatSettings.rainbow = v
    end
})

-- ChinaHat rendering logic
local ChinaHatDrawings = {}
local tau = math.pi * 2
for i = 1, ChinaHatSettings.sides do
    ChinaHatDrawings[i] = {Drawing.new('Line'), Drawing.new('Triangle')}
    ChinaHatDrawings[i][1].ZIndex = 2
    ChinaHatDrawings[i][1].Thickness = 2
    ChinaHatDrawings[i][2].ZIndex = 1
    ChinaHatDrawings[i][2].Filled = true
end

S.RS.RenderStepped:Connect(function()
    local pass = ChinaHatSettings.enabled and LP.Character and LP.Character:FindFirstChild('Head') and (Cam.CFrame.p - Cam.Focus.p).magnitude > ChinaHatSettings.minCameraDistance and LP.Character:FindFirstChildOfClass('Humanoid') and LP.Character:FindFirstChildOfClass('Humanoid').Health > 0
    for i = 1, #ChinaHatDrawings do
        local line, triangle = ChinaHatDrawings[i][1], ChinaHatDrawings[i][2]
        if pass then
            local color = ChinaHatSettings.rainbow and Color3.fromHSV((tick() % 5 / 5 - (i / #ChinaHatDrawings)) % 1, 0.5, 1) or ChinaHatSettings.color
            local pos = LP.Character.Head.Position + ChinaHatSettings.offset
            local topWorld = pos + Vector3.new(0, ChinaHatSettings.height, 0)
            local last, next = (i / ChinaHatSettings.sides) * tau, ((i + 1) / ChinaHatSettings.sides) * tau
            local lastWorld = pos + (Vector3.new(math.cos(last), 0, math.sin(last)) * ChinaHatSettings.radius)
            local nextWorld = pos + (Vector3.new(math.cos(next), 0, math.sin(next)) * ChinaHatSettings.radius)
            local lastScreen = Cam:WorldToViewportPoint(lastWorld)
            local nextScreen = Cam:WorldToViewportPoint(nextWorld)
            local topScreen = Cam:WorldToViewportPoint(topWorld)
            line.From = Vector2.new(lastScreen.X, lastScreen.Y)
            line.To = Vector2.new(nextScreen.X, nextScreen.Y)
            line.Color = color
            line.Transparency = ChinaHatSettings.circleTransparency
            line.Visible = true
            triangle.PointA = Vector2.new(topScreen.X, topScreen.Y)
            triangle.PointB = line.From
            triangle.PointC = line.To
            triangle.Color = color
            triangle.Transparency = ChinaHatSettings.hatTransparency
            triangle.Visible = true
        else
            line.Visible = false
            triangle.Visible = false
        end
    end
end)

-- === World Controller UI (LEFT) ===
local WorldGroup = Tabs.Visuals:AddLeftGroupbox('>_<')

local Lighting = S.LS
local function ensureCC()
    local cc = Lighting:FindFirstChildOfClass('ColorCorrectionEffect')
    if not cc then
        cc = Instance.new('ColorCorrectionEffect')
        cc.Parent = Lighting
        cc.Enabled = true
    end
    return cc
end
local cc = ensureCC()

local WorldConfig = {
    FogEnabled = false,
    FogColor = Color3.new(1,1,1),
    FogStart = Lighting.FogStart or 0,
    FogEnd = Lighting.FogEnd or 100,
    Shadows = false,
    ShadowColor = Lighting.ShadowColor or Color3.new(0,0,0),
    Time = Lighting.ClockTime or 12,
    Saturation = cc.Saturation or 0,
    Brightness = cc.Brightness or 0
}

local function applyWorld()
    if WorldConfig.FogEnabled then
        Lighting.FogStart = WorldConfig.FogStart
        Lighting.FogEnd = WorldConfig.FogEnd
        Lighting.FogColor = WorldConfig.FogColor
    else
        Lighting.FogStart = 1e6
        Lighting.FogEnd = 1e6
        -- Не трогаем Lighting.FogColor
    end
    Lighting.GlobalShadows = WorldConfig.Shadows
    Lighting.ShadowColor = WorldConfig.ShadowColor
    Lighting.ClockTime = WorldConfig.Time
    local cc = ensureCC()
    cc.Saturation = WorldConfig.Saturation
    cc.Brightness = WorldConfig.Brightness
end

local FogToggle = WorldGroup:AddToggle('FogEnabled', {
    Text = 'Fog',
    Default = false,
    Callback = function(v) WorldConfig.FogEnabled = v; applyWorld() end
})
FogToggle:AddColorPicker('FogColor', {
    Default = Color3.new(1,1,1),
    Title = 'Col',
    Callback = function(val) WorldConfig.FogColor = val; applyWorld() end
})
WorldGroup:AddSlider('FogStart', {
    Text = 'FStart',
    Default = WorldConfig.FogStart,
    Min = 0, Max = 10000, Rounding = 1,
    Callback = function(val) WorldConfig.FogStart = val; applyWorld() end
})
WorldGroup:AddSlider('FogEnd', {
    Text = 'FEnd',
    Default = WorldConfig.FogEnd,
    Min = 0, Max = 10000, Rounding = 1,
    Callback = function(val) WorldConfig.FogEnd = val; applyWorld() end
})
local ShadowsToggle = WorldGroup:AddToggle('Shadows', {
    Text = 'Shadows',
    Default = false,
    Callback = function(v) WorldConfig.Shadows = v; applyWorld() end
})
WorldGroup:AddSlider('Time', {
    Text = 'Time',
    Default = WorldConfig.Time,
    Min = 0, Max = 24, Rounding = 1,
    Callback = function(val) WorldConfig.Time = val; applyWorld() end
})
WorldGroup:AddSlider('Saturation', {
    Text = 'Sat',
    Default = WorldConfig.Saturation,
    Min = -1, Max = 1, Rounding = 1,
    Callback = function(val) WorldConfig.Saturation = val; applyWorld() end
})
WorldGroup:AddSlider('Brightness', {
    Text = 'Brt',
    Default = WorldConfig.Brightness,
    Min = -1, Max = 1, Rounding = 1,
    Callback = function(val) WorldConfig.Brightness = val; applyWorld() end
})

-- === LightingType Controller (RIGHT) ===
local LightingTypeGroup = Tabs.Visuals:AddRightGroupbox('>_<')
local LightingTypeList = {"Voxel", "ShadowMap", "Future"}
local LightingTypeEnum = {
    Voxel = Enum.Technology.Voxel,
    ShadowMap = Enum.Technology.ShadowMap,
    Future = Enum.Technology.Future
}
LightingTypeGroup:AddDropdown('LightingType', {
    Text = 'LightingType',
    Values = LightingTypeList,
    Default = 'Voxel',
    Callback = function(val)
        local tech = LightingTypeEnum[val]
        if tech then
            S.LS.Technology = tech
        end
    end
})
-- При запуске выставить первый режим
S.LS.Technology = LightingTypeEnum[LightingTypeList[1]]

-- === Speedhack (Player tab, right) ===
local SpeedhackGroup = Tabs.Player:AddRightGroupbox('>_<')
local SpeedhackConfig = {
    Enabled = false, -- toggle
    Active = false,  -- keybind
    Speed = 50
}
local speedHackConnection
local function updateSpeedHack(character)
    if not character then return end
    local rootPart = character:WaitForChild('HumanoidRootPart')
    local humanoid = character:WaitForChild('Humanoid')
    if speedHackConnection then speedHackConnection:Disconnect() end
    speedHackConnection = S.RS.Heartbeat:Connect(function(dt)
        if SpeedhackConfig.Enabled and SpeedhackConfig.Active then
            local move = humanoid.MoveDirection
            if move.Magnitude > 0 then
                rootPart.CFrame = rootPart.CFrame + (move.Unit * SpeedhackConfig.Speed * dt)
            end
        end
    end)
end
SpeedhackGroup:AddToggle('SpeedhackEnabled', {
    Text = 'Speedhack',
    Default = false,
    Callback = function(v)
        SpeedhackConfig.Enabled = v
        if v then
            updateSpeedHack(LP.Character)
        else
            SpeedhackConfig.Active = false
            if speedHackConnection then speedHackConnection:Disconnect() speedHackConnection = nil end
        end
    end
})
:AddKeyPicker('SpeedhackKey', {
    Default = 'None',
    Text = 'Speedhack',
    NoUI = false,
    Callback = function()
        if not SpeedhackConfig.Enabled then return end
        SpeedhackConfig.Active = not SpeedhackConfig.Active
    end
})

local speedInput = SpeedhackGroup:AddInput('SpeedhackSpeedBox', {
    Text = 'Speed',
    Default = tostring(SpeedhackConfig.Speed),
    Numeric = true,
    Finished = true,
    Callback = function(val)
        local num = tonumber(val)
        if num then
            num = math.clamp(num, 1, 2000000)
            SpeedhackConfig.Speed = num
        end
    end
})

LP.CharacterAdded:Connect(function(char)
    if SpeedhackConfig.Enabled then
        updateSpeedHack(char)
    end
end)

-- === Fly (Player tab, left) ===
local FlyGroup = Tabs.Player:AddLeftGroupbox('>_<')
local FlyConfig = {
    Enabled = false, -- toggle (мастер)
    Active = false,  -- keybind (активность)
    Speed = 1,       -- множитель (1x = 50 studs/sec)
    Keybind = Enum.KeyCode.F
}
local FlyLoop = nil
local function setNoClip(character, state)
    if not character then return end
    for _, part in ipairs(character:GetDescendants()) do
        if part:IsA('BasePart') then
            if state then
                if not part:GetAttribute('OriginalCollision') then
                    part:SetAttribute('OriginalCollision', part.CanCollide)
                    part:SetAttribute('OriginalTouch', part.CanTouch)
                    if part:GetAttribute('CanQuery') ~= nil then
                        part:SetAttribute('OriginalQuery', part.CanQuery)
                    end
                end
                part.CanCollide = false
                part.CanTouch = false
                part.CanQuery = false
            else
                if part:GetAttribute('OriginalCollision') ~= nil then
                    part.CanCollide = part:GetAttribute('OriginalCollision')
                    part.CanTouch = part:GetAttribute('OriginalTouch')
                    if part:GetAttribute('OriginalQuery') ~= nil then
                        part.CanQuery = part:GetAttribute('OriginalQuery')
                    end
                    part:SetAttribute('OriginalCollision', nil)
                    part:SetAttribute('OriginalTouch', nil)
                    part:SetAttribute('OriginalQuery', nil)
                end
            end
        end
    end
end
local function updateFly(character)
    if FlyLoop then FlyLoop:Disconnect() FlyLoop = nil end
    if not character then return end
    if not (FlyConfig.Enabled and FlyConfig.Active) then return end
    setNoClip(character, true)
    FlyLoop = S.RS.Stepped:Connect(function()
        local char = S.PS.LocalPlayer.Character
        if not char then return end
        setNoClip(char, true)
        local hrp = char:FindFirstChild('HumanoidRootPart')
        local hum = char:FindFirstChild('Humanoid')
        if not hrp or not hum then return end
        local speed = FlyConfig.Speed * 50
        local velocity = Vector3.new(0, 0, 0)
        if S.UIS:IsKeyDown(Enum.KeyCode.Space) then velocity = velocity + Vector3.new(0, speed, 0) end
        if S.UIS:IsKeyDown(Enum.KeyCode.LeftControl) then velocity = velocity + Vector3.new(0, -speed, 0) end
        if S.UIS:IsKeyDown(Enum.KeyCode.W) then velocity = velocity + (S.WS.CurrentCamera.CFrame.LookVector * speed) end
        if S.UIS:IsKeyDown(Enum.KeyCode.A) then velocity = velocity + (S.WS.CurrentCamera.CFrame.RightVector * -speed) end
        if S.UIS:IsKeyDown(Enum.KeyCode.S) then velocity = velocity + (S.WS.CurrentCamera.CFrame.LookVector * -speed) end
        if S.UIS:IsKeyDown(Enum.KeyCode.D) then velocity = velocity + (S.WS.CurrentCamera.CFrame.RightVector * speed) end
        hrp.Velocity = velocity
        hum:ChangeState('Freefall')
    end)
end
local function stopFly()
    if FlyLoop then FlyLoop:Disconnect() FlyLoop = nil end
    local char = S.PS.LocalPlayer.Character
    setNoClip(char, false)
    if char then
        local hrp = char:FindFirstChild('HumanoidRootPart')
        local hum = char:FindFirstChild('Humanoid')
        if hrp then
            hrp.Velocity = Vector3.new(0, -2, 0)
            local tempConn
            tempConn = S.RS.Stepped:Connect(function()
                if not hrp or not hrp.Parent then tempConn:Disconnect() return end
                hrp.Velocity = Vector3.new(0, hrp.Velocity.Y, 0)
                tempConn:Disconnect()
            end)
        end
        if hum then hum:ChangeState('Landing') end
    end
end
local function setFlyActive(state)
    FlyConfig.Active = state
    if FlyConfig.Enabled and FlyConfig.Active then
        updateFly(S.PS.LocalPlayer.Character)
    else
        stopFly()
    end
end
FlyGroup:AddToggle('FlyEnabled', {
    Text = 'Fly',
    Default = false,
    Callback = function(v)
        FlyConfig.Enabled = v
        if not v then
            setFlyActive(false)
        end
        if v and FlyConfig.Active then
            updateFly(S.PS.LocalPlayer.Character)
        end
    end
})
:AddKeyPicker('FlyKey', {
    Default = 'None',
    Text = 'Fly',
    NoUI = false,
    Callback = function()
        if not FlyConfig.Enabled then return end
        setFlyActive(not FlyConfig.Active)
    end
})
FlyGroup:AddInput('FlySpeed', {
    Text = 'Speed',
    Default = tostring(FlyConfig.Speed),
    Numeric = true,
    Finished = true,
    Callback = function(val)
        local num = tonumber(val)
        if num then
            num = math.clamp(num, 0.1, 100)
            FlyConfig.Speed = num
        end
    end
})
S.PS.LocalPlayer.CharacterAdded:Connect(function(char)
    if FlyConfig.Enabled and FlyConfig.Active then
        updateFly(char)
    end
end)

-- === NoRecoil (Misc tab, отдельная секция) ===
local NoRecoilGroup = Tabs.Misc:AddLeftGroupbox('>_<')

local noRecoilHook, originalNewIndex
local noRecoilEnabled = false

local function isframework(scriptInstance)
    return tostring(scriptInstance) == "Framework"
end

local function checkArgs(instance, index)
    return tostring(instance):lower():find("camera") and tostring(index) == "CFrame"
end

local function enableNoRecoil()
    if noRecoilHook then return end
    originalNewIndex = originalNewIndex or hookmetamethod(game, "__newindex", function(self, index, value)
        local callingScr = getcallingscript and getcallingscript() or nil
        if callingScr and isframework(callingScr) and checkArgs(self, index) then
            return
        end
        return originalNewIndex(self, index, value)
    end)
    noRecoilHook = true
end

local function disableNoRecoil()
    if not noRecoilHook then return end
    -- Снимаем хук: возвращаем оригинальный __newindex
    if originalNewIndex then
        hookmetamethod(game, "__newindex", originalNewIndex)
    end
    noRecoilHook = nil
end

NoRecoilGroup:AddToggle('NoRecoil', {
    Text = 'NoRecoil',
    Default = false,
    Callback = function(v)
        noRecoilEnabled = v
        if v then
            enableNoRecoil()
        else
            disableNoRecoil()
        end
    end
})
