local rs,ps,ws,cg,cam=game:GetService('RunService'),game:GetService('Players'),workspace,game:GetService('CoreGui'),workspace.CurrentCamera
local lp=ps.LocalPlayer
local esp={
    enabled=true,teamcheck=true,visiblecheck=false,outlines=true,limitdistance=false,shortnames=false,
    tracers=false,tracer_color=Color3.new(1,1,1),tracer_origin="Bottom",tracer_thickness=1,
    fixed_size_enabled=false,fixed_box_width=4,fixed_box_height=6,healthbar_thickness=1,
    maxchar=4,maxdistance=1200,fadefactor=20,arrowradius=500,arrowsize=20,arrowinfo=false,
    font='Plex',textsize=13,
    team_chams={false,Color3.new(1,1,1),Color3.new(1,1,1),.25,.75,true},
    team_boxes={false,Color3.new(),Color3.new(),0.95},team_healthbar={false,Color3.new(),Color3.new()},
    team_kevlarbar={false,Color3.new(),Color3.new()},team_arrow={false,Color3.new(),0.5},
    team_names={false,Color3.new()},team_weapon={false,Color3.new()},team_distance=false,team_health=false,
    enemy_chams={false,Color3.new(1,1,1),Color3.new(1,1,1),.25,.75,true},
    enemy_boxes={false,Color3.new(),Color3.new(),0.95},enemy_healthbar={false,Color3.new(),Color3.new()},
    enemy_kevlarbar={false,Color3.new(),Color3.new()},enemy_arrow={false,Color3.new(),0.5},
    enemy_names={false,Color3.new()},enemy_weapon={false,Color3.new()},enemy_distance=false,enemy_health=false,
    priority_chams={false,Color3.new(1,1,1),Color3.new(1,1,1),.25,.75,true},
    priority_boxes={false,Color3.new(),Color3.new(),0.95},priority_healthbar={false,Color3.new(),Color3.new()},
    priority_kevlarbar={false,Color3.new(),Color3.new()},priority_arrow={false,Color3.new(),0.5},
    priority_names={false,Color3.new()},priority_weapon={false,Color3.new()},priority_distance=false,priority_health=false,
    players={},priority_players={},connections={},visiblecheckparams={}
}

local cf,v2,c3=CFrame.new,Vector2.new,Color3.new
local m=math
local min,max,atan2,clamp,floor,sin,cos,rad=m.min,m.max,m.atan2,m.clamp,m.floor,m.sin,m.cos,m.rad
local len,sub,lower=string.len,string.sub,string.lower
local ins,fnd=table.insert,table.find

function esp:draw(t,p)local d=Drawing.new(t)if type(p)=='table'then for k,v in next,p do d[k]=v end end return d end
function esp:create(t,p)local i=Instance.new(t)if type(p)=='table'then for k,v in next,p do i[k]=v end end return i end
local folder=esp:create('Folder',{Parent=cg})
function esp:setproperties(a,b)for k,v in next,b do a[k]=v end return a end
function esp:raycast(a,b,c)c=type(c)=='table'and c or{}local p=RaycastParams.new()p.IgnoreWater=true p.FilterType=Enum.RaycastFilterType.Blacklist p.FilterDescendantsInstances=c
local r=ws:Raycast(a,b,p)if r and r.Instance.Transparency>=.25 then ins(c,r.Instance)local n=self:raycast(a,b,c)if n then r=n end end return r end
function esp.getcharacter(p)return p.Character end
function esp.checkalive(p)p=p or lp return p.Character and p.Character:FindFirstChild('Humanoid')and p.Character:FindFirstChild('Head')and p.Character:FindFirstChild('LeftUpperArm')and p.Character.Humanoid.Health>0 and p.Character.LeftUpperArm.Transparency==0 end
function esp.checkteam(p,b)p=p or lp return p~=lp and b or p.Team~=lp.Team end
function esp:checkvisible(i,o,p)p=p or{}local h=self:raycast(cam.CFrame.p,(o.Position-cam.CFrame.p).unit*500,{unpack(p),cam,lp.Character})return h and h.Instance:IsDescendantOf(i)end
function esp:check(p)if p==lp then return false end local c=self.getcharacter(p)if not self.checkalive(p)then return false elseif self.limitdistance and(c.PrimaryPart.CFrame.p-cam.CFrame.p).magnitude>self.maxdistance then return false elseif self.teamcheck and not self.checkteam(p,false)then return false elseif self.visiblecheck and not self:checkvisible(c,c.Head,self.visiblecheckparams)then return false end return true end
function esp:returnoffsets(x,y,z)return{cf(x,y,z),cf(-x,y,z),cf(x,y,-z),cf(-x,y,-z),cf(x,-y,z),cf(-x,-y,z),cf(x,-y,-z),cf(-x,-y,-z)}end
function esp:returntriangleoffsets(t)return min(t.PointA.X,t.PointB.X,t.PointC.X),min(t.PointA.Y,t.PointB.Y,t.PointC.Y),max(t.PointA.X,t.PointB.X,t.PointC.X),max(t.PointA.Y,t.PointB.Y,t.PointC.Y)end
function esp:convertnumrange(v,o1,o2,n1,n2)return(v-o1)*(n2-n1)/(o2-o1)+n1 end
function esp:fadeviadistance(d)return d.limit and 1-clamp(self:convertnumrange(floor((d.cframe.p-cam.CFrame.p).magnitude),(d.maxdistance-d.factor),d.maxdistance,0,1),0,1)or 1 end
function esp:floorvector(v)return v2(floor(v.X),floor(v.Y))end
function esp:rotatevector2(v,r)return v2(cos(r)*v.X-sin(r)*v.Y,sin(r)*v.X+cos(r)*v.Y)end
function esp:getTracerOrigin()local s=cam.ViewportSize return self.tracer_origin=="Bottom"and v2(s.X/2,s.Y)or self.tracer_origin=="Top"and v2(s.X/2,0)or self.tracer_origin=="Center"and v2(s.X/2,s.Y/2)or v2(s.X/2,s.Y)end
function esp:returnFixedOffsets(c)local w,h=self.fixed_box_width/2,self.fixed_box_height/2 return{cf(w,h,w),cf(-w,h,w),cf(w,h,-w),cf(-w,h,-w),cf(w,-h,w),cf(-w,-h,w),cf(w,-h,-w),cf(-w,-h,-w)}end

function esp:add(p)if p==lp then return end local o={
box_fill=esp:draw('Square',{Filled=true,Thickness=1}),box_outline=esp:draw('Square',{Filled=false,Thickness=1}),
box=esp:draw('Square',{Filled=false,Thickness=1,Color=c3(1,1,1)}),arrow_name_outline=esp:draw('Text',{Color=c3(),Font=2,Size=13}),
arrow_name=esp:draw('Text',{Color=c3(1,1,1),Font=2,Size=13}),arrow_bar_outline=esp:draw('Square',{Filled=true,Thickness=1}),
arrow_bar_inline=esp:draw('Square',{Filled=true,Thickness=1,Color=c3(.3,.3,.3)}),arrow_bar=esp:draw('Square',{Filled=true,Thickness=1,Color=c3(1,1,1)}),
arrow_kevlarbar_outline=esp:draw('Square',{Filled=true,Thickness=1}),arrow_kevlarbar_inline=esp:draw('Square',{Filled=true,Thickness=1,Color=c3(.3,.3,.3)}),
arrow_kevlarbar=esp:draw('Square',{Filled=true,Thickness=1,Color=c3(1,1,1)}),arrow=esp:draw('Triangle',{Filled=true,Thickness=1}),
tracer=esp:draw('Line',{Thickness=1,Color=c3(1,1,1),Transparency=1,Visible=false}),bar_outline=esp:draw('Square',{Filled=true,Thickness=1}),
bar_inline=esp:draw('Square',{Filled=true,Thickness=1,Color=c3(.3,.3,.3)}),bar=esp:draw('Square',{Filled=true,Thickness=1,Color=c3(1,1,1)}),
kevlarbar_outline=esp:draw('Square',{Filled=true,Thickness=1}),kevlarbar_inline=esp:draw('Square',{Filled=true,Thickness=1,Color=c3(.3,.3,.3)}),
kevlarbar=esp:draw('Square',{Filled=true,Thickness=1,Color=c3(1,1,1)}),name_outline=esp:draw('Text',{Color=c3(),Font=2,Size=13}),
name=esp:draw('Text',{Color=c3(1,1,1),Font=2,Size=13}),distance_outline=esp:draw('Text',{Color=c3(),Font=2,Size=13}),
distance=esp:draw('Text',{Color=c3(1,1,1),Font=2,Size=13}),weapon_outline=esp:draw('Text',{Color=c3(),Font=2,Size=13}),
weapon=esp:draw('Text',{Color=c3(1,1,1),Font=2,Size=13}),health=esp:draw('Text',{Color=c3(1,1,1),Font=2,Size=13,Center=true}),
chams={ins=esp:create('Highlight',{Name=p.Name}),Remove=function(s)s.ins:Destroy()end}}
self.players[p.Name]=o end

function esp:disable(p)local o=self.players[p.Name]if o then for k,v in next,o do if k=='chams'then v.ins.Enabled=false else v.Visible=false end end end end
function esp:remove(p)local o=self.players[p.Name]if o then for k,v in next,o do v:Remove()end end self.players[p.Name]=nil end
function esp:connect(e,c)local con=e:Connect(c)ins(self.connections,con)return con end
function esp:bindtorenderstep(n,p,c)local a={Disconnect=function()rs:UnbindFromRenderStep(n)end}rs:BindToRenderStep(n,p,c)ins(self.connections,a)return a end
function esp:clearconnections()for _,c in next,self.connections do c:Disconnect()end end

function esp:update()for n,o in next,self.players do local p=ps:FindFirstChild(n)if not p then self.players[n]=nil continue end
if self.enabled and self.checkalive(p)then local c=self.getcharacter(p)local nm=len(n)>self.maxchar and self.shortnames and sub(n,0,self.maxchar)..'..'or n
local pass=self:check(p)local d=floor((c.PrimaryPart.CFrame.p-cam.CFrame.p).Magnitude/3)..'m'local pos,os=cam:WorldToViewportPoint(c.HumanoidRootPart.Position)
local cm=c.HumanoidRootPart.CFrame local t=self:fadeviadistance({limit=self.limitdistance,cframe=cm,maxdistance=self.maxdistance,factor=self.fadefactor})
local k=p:FindFirstChild('Kevlar')and p.Kevlar.Value or 0 local h=floor(c.Humanoid.Health)local f='team_'if self.checkteam(p,false)then f='enemy_'end if fnd(self.priority_players,p)then f='priority_'end
if not(pass and os)then self:disable(p)end

o.tracer.Visible=self.tracers and os and pass
if o.tracer.Visible then local ori=self:getTracerOrigin()o.tracer.From=ori o.tracer.To=v2(pos.X,pos.Y)o.tracer.Color=self.tracer_color o.tracer.Thickness=self.tracer_thickness o.tracer.Transparency=t end

o.arrow.Visible=self[f..'arrow'][1]and pass if o.arrow.Visible then local pr=cam.CFrame:PointToObjectSpace(cm.p)local a=atan2(pr.Z,pr.X)local d=v2(cos(a),sin(a))local pt=(d*self.arrowradius*.5)+cam.ViewportSize/2
o.arrow.PointA=pt o.arrow.PointB=pt-self:rotatevector2(d,rad(30))*self.arrowsize o.arrow.PointC=pt-self:rotatevector2(d,-rad(30))*self.arrowsize o.arrow.Color=self[f..'arrow'][2]o.arrow.Transparency=not os and self[f..'arrow'][3]or 0
if self.arrowinfo then local sx,sy,bx,by=self:returntriangleoffsets(o.arrow)
o.arrow_bar.Visible=not os and o.arrow.Visible and self[f..'healthbar'][1]o.arrow_bar_inline.Visible=o.arrow_bar.Visible o.arrow_bar_outline.Visible=self.outlines and o.arrow_bar.Visible
if o.arrow_bar.Visible then o.arrow_bar.Color=self[f..'healthbar'][3]:Lerp(self[f..'healthbar'][2],h/100)o.arrow_bar.Size=self:floorvector(v2(self.healthbar_thickness,(-h/100*(by-sy+2))+3))o.arrow_bar.Position=self:floorvector(v2(sx-self.healthbar_thickness-2,sy+o.arrow_bar_outline.Size.Y))o.arrow_bar.Transparency=t
o.arrow_bar_inline.Size=self:floorvector(v2(self.healthbar_thickness,(-1*(by-sy+2))+3))o.arrow_bar_inline.Position=o.arrow_bar.Position o.arrow_bar_inline.Transparency=t
o.arrow_bar_outline.Size=self:floorvector(v2(self.healthbar_thickness,by-sy))o.arrow_bar_outline.Position=self:floorvector(v2(sx-self.healthbar_thickness-1,sy+1))o.arrow_bar_outline.Transparency=t end

o.arrow_kevlarbar.Visible=not os and o.arrow.Visible and self[f..'kevlarbar'][1]o.arrow_kevlarbar_inline.Visible=o.arrow_kevlarbar.Visible o.arrow_kevlarbar_outline.Visible=self.outlines and o.arrow_kevlarbar.Visible
if o.arrow_kevlarbar.Visible then o.arrow_kevlarbar.Color=self[f..'kevlarbar'][3]:Lerp(self[f..'kevlarbar'][2],k/100)o.arrow_kevlarbar.Size=self:floorvector(v2((k/100*(bx-sx)),1))o.arrow_kevlarbar.Position=self:floorvector(v2(sx,by+2))o.arrow_kevlarbar.Transparency=t
o.arrow_kevlarbar_inline.Size=self:floorvector(v2((1*(bx-sx)),1))o.arrow_kevlarbar_inline.Position=o.arrow_kevlarbar.Position o.arrow_kevlarbar_inline.Transparency=t
o.arrow_kevlarbar_outline.Size=self:floorvector(v2(bx-sx,1))o.arrow_kevlarbar_outline.Position=self:floorvector(v2(sx+1,by+3))o.arrow_kevlarbar_outline.Transparency=t end

o.arrow_name.Visible=not os and o.arrow.Visible and self[f..'names'][1]o.arrow_name_outline.Visible=self.outlines and o.arrow_name.Visible
if o.arrow_name.Visible then o.arrow_name.Text=self[f..'distance']and'['..d..'] '..nm or nm o.arrow_name.Font=Drawing.Fonts[self.font]o.arrow_name.Size=self.textsize o.arrow_name.Color=self[f..'names'][2]
o.arrow_name.Position=self:floorvector(v2(sx+(bx-sx)/2-(o.arrow_name.TextBounds.X/2),sy-o.arrow_name.TextBounds.Y-2))o.arrow_name.Transparency=t
o.arrow_name_outline.Text=o.arrow_name.Text o.arrow_name_outline.Font=o.arrow_name.Font o.arrow_name_outline.Size=o.arrow_name.Size o.arrow_name_outline.Position=o.arrow_name.Position+v2(1,1)o.arrow_name_outline.Transparency=t end end end

o.chams.ins.Enabled=self[f..'chams'][1]and pass o.chams.ins.Adornee=self[f..'chams'][1]and p.Character or nil o.chams.ins.Parent=folder
if o.chams.ins.Enabled then o.chams.ins.FillColor=self[f..'chams'][2]o.chams.ins.OutlineColor=self[f..'chams'][3]o.chams.ins.FillTransparency=self[f..'chams'][4]o.chams.ins.OutlineTransparency=self[f..'chams'][5]o.chams.ins.DepthMode=self[f..'chams'][6]and Enum.HighlightDepthMode.AlwaysOnTop or Enum.HighlightDepthMode.Occluded end

if not pass or not os then continue end local sx,bx=math.huge,-math.huge local sy,by=math.huge,-math.huge local offs
if self.fixed_size_enabled then offs=self:returnFixedOffsets(c)else local y=(cm.p-c.Head.Position).magnitude+c.Head.Size.Y/2 local x1=(cm.p-c.RightHand.Position).magnitude local x2=(cm.p-c.LeftHand.Position).magnitude local my1=(cm.p-c.RightFoot.Position).magnitude local my2=(cm.p-c.LeftFoot.Position).magnitude local my=my1>my2 and my1 or my2 local mx=x1<x2 and x1 or x2 offs=self:returnoffsets(mx,y,my,c.HumanoidRootPart.Size.Z/2)end

for _,v in next,offs do local p=cam:WorldToViewportPoint(cm*v.p)if sx>p.X then sx=p.X end if bx<p.X then bx=p.X end if sy>p.Y then sy=p.Y end if by<p.Y then by=p.Y end end

o.box.Visible=self[f..'boxes'][1]o.box_fill.Visible=o.box.Visible o.box_outline.Visible=self.outlines and o.box.Visible
if o.box.Visible then o.box.Color=self[f..'boxes'][2]o.box.Size=self:floorvector(v2(bx-sx,by-sy))o.box.Position=self:floorvector(v2(sx,sy))o.box.Transparency=t
o.box_fill.Size=o.box.Size o.box_fill.Position=o.box.Position o.box_fill.Color=self[f..'boxes'][3]o.box_fill.Transparency=min(self[f..'boxes'][4],t)
o.box_outline.Size=o.box.Size o.box_outline.Position=o.box.Position+v2(1,1)o.box_outline.Transparency=t end

o.bar.Visible=self[f..'healthbar'][1]o.bar_inline.Visible=o.bar.Visible o.bar_outline.Visible=self.outlines and o.bar.Visible
if o.bar.Visible then o.bar.Color=self[f..'healthbar'][3]:Lerp(self[f..'healthbar'][2],h/100)o.bar.Size=self:floorvector(v2(self.healthbar_thickness,(-h/100*(by-sy+2))+3))o.bar.Position=self:floorvector(v2(sx-self.healthbar_thickness-2,sy+o.bar_outline.Size.Y))o.bar.Transparency=t
o.bar_inline.Size=self:floorvector(v2(self.healthbar_thickness,(-1*(by-sy+2))+3))o.bar_inline.Position=o.bar.Position o.bar_inline.Transparency=t
o.bar_outline.Size=self:floorvector(v2(self.healthbar_thickness,by-sy))o.bar_outline.Position=self:floorvector(v2(sx-self.healthbar_thickness-1,sy+1))o.bar_outline.Transparency=t end

o.kevlarbar.Visible=self[f..'kevlarbar'][1]o.kevlarbar_inline.Visible=o.kevlarbar.Visible o.kevlarbar_outline.Visible=self.outlines and o.kevlarbar.Visible
if o.kevlarbar.Visible then o.kevlarbar.Color=self[f..'kevlarbar'][3]:Lerp(self[f..'kevlarbar'][2],k/100)o.kevlarbar.Size=self:floorvector(v2((k/100*(bx-sx)),1))o.kevlarbar.Position=self:floorvector(v2(sx,by+2))o.kevlarbar.Transparency=t
o.kevlarbar_inline.Size=self:floorvector(v2((1*(bx-sx)),1))o.kevlarbar_inline.Position=o.kevlarbar.Position o.kevlarbar_inline.Transparency=t
o.kevlarbar_outline.Size=self:floorvector(v2(bx-sx,1))o.kevlarbar_outline.Position=self:floorvector(v2(sx+1,by+3))o.kevlarbar_outline.Transparency=t end

o.distance.Visible=not self[f..'names'][1]and self[f..'distance']o.distance_outline.Visible=self.outlines and o.distance.Visible
if o.distance.Visible then o.distance.Text='['..d..']'o.distance.Font=Drawing.Fonts[self.font]o.distance.Size=self.textsize o.distance.Color=self[f..'names'][2]
o.distance.Position=self:floorvector(v2(sx+(bx-sx)/2-(o.distance.TextBounds.X/2),sy-o.distance.TextBounds.Y-2))o.distance.Transparency=t
o.distance_outline.Text=o.distance.Text o.distance_outline.Font=o.distance.Font o.distance_outline.Size=o.distance.Size o.distance_outline.Position=o.distance.Position+v2(1,1)o.distance_outline.Transparency=t end

o.name.Visible=self[f..'names'][1]o.name_outline.Visible=self.outlines and o.name.Visible
if o.name.Visible then o.name.Text=self[f..'distance']and'['..d..'] '..nm or nm o.name.Font=Drawing.Fonts[self.font]o.name.Size=self.textsize o.name.Color=self[f..'names'][2]
o.name.Position=self:floorvector(v2(sx+(bx-sx)/2-(o.name.TextBounds.X/2),sy-o.name.TextBounds.Y-2))o.name.Transparency=t
o.name_outline.Text=o.name.Text o.name_outline.Font=o.name.Font o.name_outline.Size=o.name.Size o.name_outline.Position=o.name.Position+v2(1,1)o.name_outline.Transparency=t end

o.health.Visible=h~=100 and h~=0 and self[f..'health']if o.health.Visible then o.health.Text=tostring(h)o.health.Font=Drawing.Fonts[self.font]o.health.Size=self.textsize o.health.Outline=self.outlines
o.health.Color=self[f..'healthbar'][3]:Lerp(self[f..'healthbar'][2],h/100)o.health.Position=self:floorvector(v2(sx-3,o.bar.Position.Y+o.bar.Size.Y-o.health.TextBounds.Y+5))o.health.Transparency=t end

o.weapon.Visible=self[f..'weapon'][1]o.weapon_outline.Visible=self.outlines and o.weapon.Visible
if o.weapon.Visible then o.weapon.Text=lower(c.EquippedTool.Value)or nil o.weapon.Font=Drawing.Fonts[self.font]o.weapon.Size=self.textsize o.weapon.Color=self[f..'weapon'][2]
o.weapon.Position=self:floorvector(v2(sx+(bx-sx)/2-(o.weapon.TextBounds.X/2),by+4))o.weapon.Transparency=t
o.weapon_outline.Text=o.weapon.Text o.weapon_outline.Font=o.weapon.Font o.weapon_outline.Size=o.weapon.Size o.weapon_outline.Position=o.weapon.Position+v2(1,1)o.weapon_outline.Transparency=t end else self:disable(p)end end end

for _,p in next,ps:GetPlayers()do esp:add(p)end
esp:connect(ps.PlayerAdded,function(p)esp:add(p)end)
esp:connect(ps.PlayerRemoving,function(p)esp:remove(p)end)
esp:bindtorenderstep('esp',999,esp.update)

return esp
