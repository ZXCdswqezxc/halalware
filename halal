wait(3)
loadstring(game:HttpGet('https://pastebin.com/raw/gimbTwW1'))() -- ac bypass dont touch
local S = {
    PS = game:GetService('Players'), RS = game:GetService('RunService'), WS = game:GetService('Workspace'),
    UIS = game:GetService('UserInputService'), TS = game:GetService('TweenService'), LS = game:GetService('Lighting'),
    CG = game:GetService('CoreGui'), SG = game:GetService('StarterGui'), SP = game:GetService('StarterPack'),
    SR = game:GetService('StarterPlayer'), RP = game:GetService('ReplicatedStorage'), RF = game:GetService('ReplicatedFirst'),
    SS = game:GetService('SoundService'), TV = game:GetService('TeleportService'), BS = game:GetService('BadgeService'),
    PL = game:GetService('PolicyService'), PF = game:GetService('PathfindingService'), DS = game:GetService('DataStoreService'),
    CH = game:GetService('Chat'), MSG = game:GetService('MessagingService'), FS = game:GetService('FriendService'),
    INS = game:GetService('InsertService'), TM = game:GetService('Teams'), SGv = game:GetService('StarterGear'),
    VR = game:GetService('VRService'), GU = game:GetService('GuiService'), TScr = game:GetService('TextService'),
    DB = game:GetService('Debris'), PH = game:GetService('PhysicsService'), LOC = game:GetService('LocalizationService'),
    TST = game:GetService('TestService'), VS = game:GetService('VoiceChatService'), NS = game:GetService('NotificationService'),
    HS = game:GetService('HttpService'), CS = game:GetService('CollectionService'), CP = game:GetService('ContentProvider'),
    PPS = game:GetService('ProximityPromptService'), TCS = game:GetService('TextChatService'), ES = game:GetService('ExperienceService'),
    PSS = game:GetService('PointsService'), GS = game:GetService('GroupService'), MS = game:GetService('MarketplaceService'),
}

local M = {
    abs = math.abs, floor = math.floor, ceil = math.ceil, sqrt = math.sqrt, clamp = math.clamp,
    min = math.min, max = math.max, atan2 = math.atan2, acos = math.acos, asin = math.asin,
    cos = math.cos, sin = math.sin, tan = math.tan, rad = math.rad, deg = math.deg, random = math.random
}

local T = {
    insert = table.insert, remove = table.remove, sort = table.sort, find = table.find, concat = table.concat,
    clear = table.clear
}

local STR = {
    sub = string.sub, gsub = string.gsub, lower = string.lower, upper = string.upper,
    rep = string.rep, split = string.split, fmt = string.format
}

local repo = 'https://raw.githubusercontent.com/violin-suzutsuki/LinoriaLib/main/'
local Library = loadstring(game:HttpGet('https://raw.githubusercontent.com/ZXCdswqezxc/halalware/refs/heads/main/library'))()
local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()

-- Функция-обертка для тоглов с уведомлениями
local function addToggleWithNotify(group, id, options)
    local originalCallback = options.Callback
    options.Callback = function(v)
        originalCallback(v)
        Library:Notify(">_< " .. (v and "on" or "off"), 3)
    end
    return group:AddToggle(id, options)
end

local G = {
    -- Трейсеры
    lastTracerUpdate = 0,
    tracerUpdateInterval = 1/60,
    ActiveTracers = {},
    TracerCount = 0,
    
    -- AutoAir
    autoAirDebounce = false,
    autoAirDebounceTime = 0.03, -- 100 мс между выстрелами
    
    -- Общие переменные дебаунса
    hitEffectDebounce = false,
    lastDamageTick = 0,
    
    -- Crosshair
    crosshairLines = {},
    crosshairOutlines = {},
    crosshairAngle = 0,
    crosshairConn = nil,
    
    -- Camera
    originalPlayerMaxZoom = 0,
    
    -- Target Strafe variables have been removed
    
    -- RapidFireM1
    rapidFireM1Firing = false,
    rapidFireM1Debounce = false,
    rapidFireM1MinDelay = 0,
    rapidFireM1ConnBegan = nil,
    rapidFireM1ConnEnded = nil,
    rapidFireM1CharConn = nil,
    
    -- YawLocker
    yawLockerConnection = nil,
    yawJitterState = 1,
    yawJitterTimer = 0,
    
    -- Grip
    GripSettings = {
        Enabled = false,
        Position = Vector3.new(0, 0, 0),
        Rotation = Vector3.new(0, 0, 0)
    },
    
    -- BulletTP
    bulletTpConns = {},
    bulletTpCFOffset = function(origin, target)
        local actualOrigin = origin * CFrame.new(0, -1, 0, 1, 0, 0, 0, 0, 1, 0, -1, 0)
        return actualOrigin:ToObjectSpace(target):inverse()
    end
}

local V3, V2, CF, C3, U2, RP = Vector3, Vector2, CFrame, Color3, UDim2, RaycastParams
local RND, SND, HRT = S.RS.RenderStepped, S.RS.Stepped, S.RS.Heartbeat
local LP = S.PS.LocalPlayer
local Char = LP.Character or LP.CharacterAdded:Wait()
local Body = {
    Hum = Char:FindFirstChildOfClass('Humanoid'),
    HRP = Char:FindFirstChild('HumanoidRootPart'),
    Head = Char:FindFirstChild('Head'),
    Tor = Char:FindFirstChild('Torso') or Char:FindFirstChild('UpperTorso'),
    LA = Char:FindFirstChild('Left Arm') or Char:FindFirstChild('LeftUpperArm'),
    RA = Char:FindFirstChild('Right Arm') or Char:FindFirstChild('RightUpperArm'),
    LL = Char:FindFirstChild('Left Leg') or Char:FindFirstChild('LeftUpperLeg'),
    RL = Char:FindFirstChild('Right Leg') or Char:FindFirstChild('RightUpperLeg'),
}

local Cam, Mse, Bp, Tm, UID, PGui = S.WS.CurrentCamera, LP:GetMouse(), LP:FindFirstChildOfClass('Backpack'), LP.Team, LP.UserId, LP:FindFirstChildOfClass('PlayerGui')

local Window = Library:CreateWindow({
    Title = 'Halalware',
    Center = true,
    AutoShow = true,
    TabPadding = 8,
    MenuFadeTime = 0.2
})

local Tabs = {
    Combat = Window:AddTab('Combat'),
    Misc = Window:AddTab('Misc'),
    Visuals = Window:AddTab('Visuals'),
    Player = Window:AddTab('Player'),
    Config = Window:AddTab('Config'),
}

ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)
SaveManager:IgnoreThemeSettings()
local MenuGroup = Tabs.Config:AddLeftGroupbox('Menu')
MenuGroup:AddLabel('Menu bind'):AddKeyPicker('MenuKeybind', {
    Default = 'None',
    NoUI = true,
    Text = 'Menu',
})
Library.ToggleKeybind = Options.MenuKeybind
ThemeManager:ApplyToTab(Tabs.Config)
SaveManager:BuildConfigSection(Tabs.Config)
SaveManager:LoadAutoloadConfig()

-- === HUD Section in Config ===
local HUDGroup = Tabs.Config:AddRightGroupbox('HUD')
HUDGroup:AddToggle('ShowWatermark', {
    Text = 'WMark',
    Default = false,
    Callback = function(v)
        if v then
            local name = LP and LP.Name or 'Player'
            Library:SetWatermark('halalware.skid | ' .. name)
        else
            Library:SetWatermark('')
        end
    end
})
HUDGroup:AddToggle('ShowKeybinds', {
    Text = 'Keys',
    Default = false,
    Callback = function(v)
        if Library.KeybindFrame then
            Library.KeybindFrame.Visible = v
        end
    end
})

local ESPConfig = {
    Enabled = false,
    MaxDistance = 200,
    Box = {
        Enable = false, -- выключено по умолчанию
        Type = 'Full',
        Font = 'ProggyClean',
        Color = Color3.fromRGB(255, 255, 255),
        Filled = {
            Enable = false,
            Gradient = {
                Enable = false,
                Color = {
                    Start = Color3.fromRGB(255, 255, 255),
                    End = Color3.fromRGB(255, 255, 255),
                },
                Rotation = {
                    Enable = false,
                    Auto = true,
                },
                Transparency = 0.3,
            }
        }
    },
    Text = {
        Enable = false,
        Name = {
            Enable = false,
            Teamcheck = true,
            Color = Color3.fromRGB(255, 255, 255),
        },
        Studs = {
            Enable = false,
            Color = Color3.fromRGB(255, 255, 255),
        },
        Tool = {
            Enable = false,
            Color = Color3.fromRGB(255, 255, 255),
        },
    },
    Bars = {
        Enable = false,
        Health = {
            ShowOutline = false,
            Enable = false,
            Lerp = true,
            Color1 = Color3.fromRGB(255, 255, 255)
        }
    }
}

local ESPGroup = Tabs.Visuals:AddLeftGroupbox('>_<')
addToggleWithNotify(ESPGroup, 'ESPEnabled', {
    Text = 'ESP',
    Default = false,
    Callback = function(v) ESPConfig.Enabled = v end
})
ESPGroup:AddSlider('ESPMaxDist', {
    Text = 'MaxDistance',
    Min = 50, Max = 10000, Default = ESPConfig.MaxDistance,
    Rounding = 0,
    Callback = function(v) ESPConfig.MaxDistance = v end
})
ESPGroup:AddToggle('ESPBox', {
    Text = 'Box',
    Default = false,
    Callback = function(v) ESPConfig.Box.Enable = v end
}):AddColorPicker('ESPBoxColor', {
    Default = ESPConfig.Box.Color,
    Callback = function(v) ESPConfig.Box.Color = v end
})
ESPGroup:AddToggle('ESPBoxFilled', {
    Text = 'Filled',
    Default = false,
    Callback = function(v) ESPConfig.Box.Filled.Enable = v end
}):AddColorPicker('ESPBoxGradStart', {
    Default = ESPConfig.Box.Filled.Gradient.Color.Start,
    Callback = function(v) ESPConfig.Box.Filled.Gradient.Color.Start = v end
}):AddColorPicker('ESPBoxGradEnd', {
    Default = ESPConfig.Box.Filled.Gradient.Color.End,
    Callback = function(v) ESPConfig.Box.Filled.Gradient.Color.End = v end
})
ESPGroup:AddToggle('ESPBoxGradient', {
    Text = 'GradAnim',
    Default = false,
    Callback = function(v) ESPConfig.Box.Filled.Gradient.Enable = v end
})
ESPGroup:AddSlider('ESPBoxGradTrans', {
    Text = 'GradTrans',
    Min = 0, Max = 1, Default = ESPConfig.Box.Filled.Gradient.Transparency, Rounding = 2,
    Callback = function(v) ESPConfig.Box.Filled.Gradient.Transparency = v end
})
ESPGroup:AddToggle('ESPText', {
    Text = 'Text',
    Default = false,
    Callback = function(v) ESPConfig.Text.Enable = v end
})
ESPGroup:AddToggle('ESPName', {
    Text = 'Name',
    Default = false,
    Callback = function(v) ESPConfig.Text.Name.Enable = v end
}):AddColorPicker('ESPNameColor', {
    Default = ESPConfig.Text.Name.Color,
    Callback = function(v) ESPConfig.Text.Name.Color = v end
})
ESPGroup:AddToggle('ESPStuds', {
    Text = 'Studs',
    Default = false,
    Callback = function(v) ESPConfig.Text.Studs.Enable = v end
}):AddColorPicker('ESPStudsColor', {
    Default = ESPConfig.Text.Studs.Color,
    Callback = function(v) ESPConfig.Text.Studs.Color = v end
})
ESPGroup:AddToggle('ESPTool', {
    Text = 'Tool',
    Default = false,
    Callback = function(v) ESPConfig.Text.Tool.Enable = v end
}):AddColorPicker('ESPToolColor', {
    Default = ESPConfig.Text.Tool.Color,
    Callback = function(v) ESPConfig.Text.Tool.Color = v end
})
ESPGroup:AddToggle('ESPHealthbar', {
    Text = 'Healthbar',
    Default = false,
    Callback = function(v) ESPConfig.Bars.Health.Enable = v end
}):AddColorPicker('ESPHealthbarColor', {
    Default = ESPConfig.Bars.Health.Color1,
    Callback = function(v) ESPConfig.Bars.Health.Color1 = v end
})

-- === Bullet Tracers UI (ENGLISH, SHORT) ===
local BulletTracersGroup = Tabs.Visuals:AddRightGroupbox('>_<')

local BulletTracersConfig = {
    Enabled = false,
    Color1 = C3.new(1,1,1),
    Color2 = C3.new(1,1,1),
    Thickness = 1,
    Texture = "rbxassetid://446111271"
}
local BulletTextures = {
    ["Starhook"] = "rbxassetid://446111271",
    ["Chain"] = "rbxassetid://3029306948",
    ["Lightning"] = "rbxassetid://7216850022",
    ["Beam"] = "rbxassetid://1263079249"
}

local BulletToggle = addToggleWithNotify(BulletTracersGroup, 'BulletTracersEnabled', {
    Text = 'Tracer',
    Default = false,
    Callback = function(v) BulletTracersConfig.Enabled = v end
})
BulletToggle:AddColorPicker('BulletTracersColor1', {
    Default = BulletTracersConfig.Color1,
    Title = 'C1',
    Callback = function(val) BulletTracersConfig.Color1 = val end
})
BulletToggle:AddColorPicker('BulletTracersColor2', {
    Default = BulletTracersConfig.Color2,
    Title = 'C2',
    Callback = function(val) BulletTracersConfig.Color2 = val end
})
BulletTracersGroup:AddSlider('BulletTracersThickness', {
    Text = 'Thick',
    Default = BulletTracersConfig.Thickness,
    Min = 0.1, Max = 10, Rounding = 1,
    Callback = function(val) BulletTracersConfig.Thickness = val end
})
BulletTracersGroup:AddDropdown('BulletTracersTexture', {
    Text = 'Tex',
    Values = {"Starhook", "Chain", "Lightning", "Beam"},
    Default = 'Starhook',
    Callback = function(val) BulletTracersConfig.Texture = BulletTextures[val] end
})

-- === Bullet Tracers Logic (ONLY) ===
-- Состояние оружия
local gunState = {
    current_tool = nil,
    previous_ammo = 0,
    recently_shot = false,
    connections = {}
}

-- Определение игры и путей к пулям
local function detectGame()
    local placeId = game.PlaceId
    
    local gameData = {
        -- Da Hood
        [2788229376] = { BN = "BULLET_RAYS", BBN = "GunBeam", BP = "Ignored.Siren.Radius" },
        [71189885129233] = { BN = "BULLET_RAYS", BBN = "GunBeam", BP = "Ignored" },
        [5602055394] = { BN = "BULLET_RAYS", BBN = "GunBeam", BP = "Ignored" },
        [17403265390] = { BN = "Part", BBN = "gb", BP = "" },
        [17403166075] = { BN = "Part", BBN = "gb", BP = "" },
        [18111448661] = { BN = "Part", BBN = "gb", BP = "" },
        [15186202290] = { BN = "Part", BBN = "gb", BP = "" },
        [11143225577] = { BN = "BULLET_RAYS", BBN = "GunBeam", BP = "" },
        [15763494605] = { BN = "BULLET_RAYS", BBN = "GunBeam", BP = "" },
        [15166543806] = { BN = "BULLET_RAYS", BBN = "GunBeam", BP = "" },
        [17897702920] = { BN = "BULLET_RAYS", BBN = "GunBeam", BP = "" },
        [16033173781] = { BN = "BULLET_RAYS", BBN = "GunBeam", BP = "Ignored.Siren.Radius" },
        [7213786345] = { BN = "BULLET_RAYS", BBN = "GunBeam", BP = "Ignored.Siren.Radius" },
        [9825515356] = { BN = "BULLET_RAYS", BBN = "GunBeam", BP = "Ignored" },
        [16859411452] = { BN = "bulletray", BBN = "beam", BP = "Ignored" },
        [14277620939] = { BN = "BULLET_RAYS", BBN = "GunBeam", BP = "Ignored" },
        [0] = { BN = "BULLET_RAYS", BBN = "GunBeam", BP = "Ignored" }
    }
    
    local data = gameData[placeId] or gameData[0]
    return data
end

-- Получение пути к пулям
local function getPath(root, path)
    if path == "" then return root end
    local parts = STR.split(path, ".")
    local current = root
    for _, part in ipairs(parts) do
        current = current:FindFirstChild(part)
        if not current then return nil end
    end
    return current
end

-- Создание луча (beam)
local function createBeam(from, to, color1, color2, thickness, texture)
    -- Создаем невидимую основную часть
    local mainPart = Instance.new("Part")
    mainPart.Name = "BulletTracer"
    mainPart.Parent = S.WS
    mainPart.Size = V3.new(0, 0, 0)
    mainPart.Massless = true
    mainPart.Transparency = 1
    mainPart.CanCollide = false
    mainPart.Position = from
    mainPart.Anchored = true
    
    -- Создаем две точки для луча
    local part0 = Instance.new("Part")
    part0.Parent = mainPart
    part0.Size = V3.new(0, 0, 0)
    part0.Massless = true
    part0.Transparency = 1
    part0.CanCollide = false
    part0.Position = from
    part0.Anchored = true
    
    local part1 = Instance.new("Part")
    part1.Parent = mainPart
    part1.Size = V3.new(0, 0, 0)
    part1.Massless = true
    part1.Transparency = 1
    part1.CanCollide = false
    part1.Position = to
    part1.Anchored = true
    
    -- Создаем точки крепления для луча
    local attachment0 = Instance.new("Attachment")
    attachment0.Parent = part0
    
    local attachment1 = Instance.new("Attachment")
    attachment1.Parent = part1
    
    -- Создаем сам луч с градиентом цвета
    local beam = Instance.new("Beam")
    beam.Texture = texture
    beam.TextureMode = Enum.TextureMode.Wrap
    beam.TextureLength = 10
    beam.LightEmission = 1
    beam.LightInfluence = 1
    beam.FaceCamera = true
    beam.ZOffset = -1
    beam.Transparency = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 0),
        NumberSequenceKeypoint.new(1, 1),
    })
    beam.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, color1),
        ColorSequenceKeypoint.new(1, color2),
    })
    beam.Attachment0 = attachment0
    beam.Attachment1 = attachment1
    beam.Width0 = thickness
    beam.Width1 = thickness
    beam.Enabled = true
    beam.Parent = mainPart
    
    -- Уничтожаем луч через указанное время
    task.delay(0.4, function()
        mainPart:Destroy()
    end)
end

-- Функция для получения оружия локального игрока
local function getGun(player)
    if not player or not player.Character then return nil end
    
    local tool = player.Character:FindFirstChildWhichIsA("Tool")
    if not tool then return nil end
    
    local gunInfo = {}
    
    -- Ищем значение патронов в оружии
    local descendants = tool:GetDescendants()
    for _, obj in ipairs(descendants) do
        if (STR.lower(obj.Name):find("ammo") and not STR.lower(obj.Name):find("max") and
            (obj.ClassName == "IntValue" or obj.ClassName == "NumberValue")) then
            gunInfo.ammo = obj
            gunInfo.tool = tool
            return gunInfo
        end
    end
    
    return nil
end

-- Функция для настройки отслеживания оружия
local function setupGunTracking(player)
    -- Очищаем текущие соединения
    for _, connection in ipairs(gunState.connections) do
        if connection then connection:Disconnect() end
    end
    gunState.connections = {}
    
    -- Если персонаж игрока не существует, создаем соединение на его появление
    if not player.Character then
        table.insert(gunState.connections, player.CharacterAdded:Connect(function(character)
            setupGunTracking(player)
        end))
        return
    end
    
    -- Отслеживаем добавление/удаление оружия
    table.insert(gunState.connections, player.Character.ChildAdded:Connect(function(child)
        if child:IsA("Tool") then
            local gun = getGun(player)
            if gun then
                gunState.current_tool = gun.tool
                gunState.previous_ammo = gun.ammo.Value
                
                -- Отслеживаем изменение количества патронов
                table.insert(gunState.connections, gun.ammo.Changed:Connect(function()
                    local new_ammo = gun.ammo.Value
                    if new_ammo < gunState.previous_ammo then
                        gunState.recently_shot = true
                        task.wait() -- Короткая пауза для обнаружения пули
                        gunState.recently_shot = false
                    end
                    gunState.previous_ammo = new_ammo
                end))
            end
        end
    end))
    
    table.insert(gunState.connections, player.Character.ChildRemoved:Connect(function(child)
        if child == gunState.current_tool then
            gunState.current_tool = nil
            gunState.previous_ammo = 0
        end
    end))
    
    -- Проверяем наличие оружия сразу
    local gun = getGun(player)
    if gun then
        gunState.current_tool = gun.tool
        gunState.previous_ammo = gun.ammo.Value
        
        -- Отслеживаем изменение количества патронов
        table.insert(gunState.connections, gun.ammo.Changed:Connect(function()
            local new_ammo = gun.ammo.Value
            if new_ammo < gunState.previous_ammo then
                gunState.recently_shot = true
                task.wait() -- Короткая пауза для обнаружения пули
                gunState.recently_shot = false
            end
            gunState.previous_ammo = new_ammo
        end))
    end
end

-- Основная функция для настройки эффектов пуль
local function setupBulletEffects()
    local gameData = detectGame()
    local bulletPath = getPath(S.WS, gameData.BP) or S.WS
    
    -- Настраиваем отслеживание оружия локального игрока
    setupGunTracking(LP)
    
    -- Отслеживаем добавление персонажа, если он еще не существует
    if not LP.Character then
        LP.CharacterAdded:Connect(function(character)
            setupGunTracking(LP)
        end)
    end
    
    -- Следим за созданием новых пуль
    bulletPath.ChildAdded:Connect(function(object)
        if not BulletTracersConfig.Enabled then return end
        
        -- Проверяем, чтобы это была пуля с правильным именем и недавно выстрелил локальный игрок
        if object.Name == gameData.BN and gunState.recently_shot then
            task.spawn(function()
                local gunBeam = object:WaitForChild(gameData.BBN, 0.2)
                if not gunBeam then return end
                
                local startPos = object.Position
                local endPos = gunBeam.Attachment1.WorldPosition
                
                -- Удаляем оригинальный луч
                gunBeam:Destroy()
                
                -- Создаем трейсер
                createBeam(
                    startPos, 
                    endPos, 
                    BulletTracersConfig.Color1, 
                    BulletTracersConfig.Color2, 
                    BulletTracersConfig.Thickness,
                    BulletTracersConfig.Texture
                )
            end)
        end
    end)
end

-- Запускаем скрипт
setupBulletEffects()

-- Старый код bullet tracers удален для избежания конфликтов с новой реализацией

local ESPCache, ESPConnections = {}, {}
local gui_inset = S.GU:GetGuiInset()

local function make_text(parent, font)
    local d = Instance.new("TextLabel")
    d.Parent = parent
    d.Size = U2.new(0, 4, 0, 4)
    d.BackgroundTransparency = 1
    d.TextColor3 = Color3.fromRGB(255,255,255)
    d.TextStrokeTransparency = 0
    d.TextScaled = false
    d.TextSize = 10
    d.TextStrokeColor3 = Color3.fromRGB(0,0,0)
    d.Font = font or Enum.Font.SourceSans
    return d
end

local function clear_esp(player)
    local cache = ESPCache[player]
    if not cache then return end
    if cache.Box and cache.Box.Full then
        cache.Box.Full.Square.Visible = false
        cache.Box.Full.Outline.Visible = false
        cache.Box.Full.Inline.Visible = false
        if cache.Box.Full.Filled then
            cache.Box.Full.Filled.Visible = false
        end
    end
    if cache.Text then
        if cache.Text.Studs then cache.Text.Studs.Visible = false end
        if cache.Text.Tool then cache.Text.Tool.Visible = false end
        if cache.Text.Name then cache.Text.Name.Visible = false end
    end
    if cache.Bars then
        if cache.Bars.Health and cache.Bars.Health.Frame then
            cache.Bars.Health.Frame.Visible = false
            cache.Bars.Health.Outline.Visible = false
        end
    end
end

local function render_esp(player)
    if not player then return end
    ESPCache[player] = ESPCache[player] or {}
    local cache = ESPCache[player]
    cache.Box = cache.Box or {}
    cache.Bars = cache.Bars or {}
    cache.Text = cache.Text or {}
    cache.Box.Full = cache.Box.Full or {
        Square = Drawing.new("Square"),
        Inline = Drawing.new("Square"),
        Outline = Drawing.new("Square"),
        Filled = Instance.new('Frame', Instance.new('ScreenGui', S.CG))
    }
    local Studs = Instance.new("ScreenGui")
    Studs.Parent = S.CG
    local Name = Instance.new("ScreenGui")
    Name.Parent = S.CG
    local Tool = Instance.new("ScreenGui")
    Tool.Parent = S.CG
    cache.Text.Studs = make_text(Studs)
    cache.Text.Tool = make_text(Tool)
    cache.Text.Name = make_text(Name)
    local healthGui = Instance.new("ScreenGui")
    healthGui.Name = player.Name .. "_HealthBar"
    healthGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    healthGui.Parent = S.CG
    local healthOutline = Instance.new("Frame")
    healthOutline.BackgroundColor3 = Color3.new(0, 0, 0)
    healthOutline.BorderSizePixel = 0
    healthOutline.Name = "Outline"
    healthOutline.Parent = healthGui
    local healthFill = Instance.new("Frame")
    healthFill.BackgroundTransparency = 0
    healthFill.BorderSizePixel = 0
    healthFill.Name = "Fill"
    healthFill.Parent = healthOutline
    healthFill.BackgroundColor3 = ESPConfig.Bars.Health.Color1
    cache.Bars.Health = {
        Gui = healthGui,
        Outline = healthOutline,
        Frame = healthFill
    }
end

local function update_esp(player)
    if not player or not ESPCache[player] then return end
    local character = player.Character
    if not character or not LP.Character then return end
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    local client_root_part = LP.Character:FindFirstChild("HumanoidRootPart")
    local humanoid = character:FindFirstChildWhichIsA("Humanoid")
    if not rootPart or not humanoid or not client_root_part then 
        clear_esp(player)
        return 
    end
    if (client_root_part.Position - rootPart.Position).Magnitude > ESPConfig.MaxDistance or not ESPConfig.Enabled then
        clear_esp(player)
        return
    end
    local hrp2D, onScreen = S.WS.CurrentCamera:WorldToViewportPoint(rootPart.Position)
    local charSize = (S.WS.CurrentCamera:WorldToViewportPoint(rootPart.Position - V3.new(0, 1, 0)).Y - S.WS.CurrentCamera:WorldToViewportPoint(rootPart.Position + V3.new(0, 3, 0)).Y) / 2
    local size = V2.new(M.floor(charSize * 1.5), M.floor(charSize * 3.2)) 
    local position = V2.new(M.floor(hrp2D.X - charSize * 1.5 / 2), M.floor(hrp2D.Y - charSize * 3 / 2))
    local cache = ESPCache[player]
    if not onScreen then
        clear_esp(player)
        return
    end
    if ESPConfig.Box.Enable then
        if ESPConfig.Box.Type == "Full" then
            cache.Box.Full.Square.Visible = true
            cache.Box.Full.Square.Position = position
            cache.Box.Full.Square.Size = size
            cache.Box.Full.Square.Color = ESPConfig.Box.Color
            cache.Box.Full.Square.Thickness = 2
            cache.Box.Full.Square.Filled = false
            cache.Box.Full.Square.ZIndex = 9e9
            cache.Box.Full.Outline.Visible = true
            cache.Box.Full.Outline.Position = position - V2.new(1, 1)
            cache.Box.Full.Outline.Size = size + V2.new(2, 2)
            cache.Box.Full.Outline.Color = Color3.new(0, 0, 0)
            cache.Box.Full.Outline.Thickness = 1
            cache.Box.Full.Inline.Visible = true
            cache.Box.Full.Inline.Position = position + V2.new(1, 1)
            cache.Box.Full.Inline.Size = size - V2.new(2, 2)
            cache.Box.Full.Inline.Color = Color3.new(0, 0, 0)
            cache.Box.Full.Inline.Thickness = 1
            cache.Box.Full.Inline.Filled = false
            if ESPConfig.Box.Filled.Enable and cache.Box.Full.Filled then
                cache.Box.Full.Filled.Position = U2.new(0, position.X, 0, position.Y - S.GU:GetGuiInset().Y)
                cache.Box.Full.Filled.Size = U2.new(0, size.X, 0, size.Y)
                cache.Box.Full.Filled.BackgroundTransparency = ESPConfig.Box.Filled.Gradient.Transparency or 0.5
                cache.Box.Full.Filled.BackgroundColor3 = Color3.new(1, 1, 1)
                cache.Box.Full.Filled.Visible = true
                cache.Box.Full.Filled.ZIndex = -9e9
                local gradient = cache.Box.Full.Filled:FindFirstChild("Gradient") or Instance.new("UIGradient")
                gradient.Name = "Gradient"
                gradient.Color = ColorSequence.new({
                    ColorSequenceKeypoint.new(0, ESPConfig.Box.Filled.Gradient.Color.Start),
                    ColorSequenceKeypoint.new(1, ESPConfig.Box.Filled.Gradient.Color.End)
                })
                if ESPConfig.Box.Filled.Gradient.Enable then
                    gradient.Rotation = M.sin(tick() * 2) * 180
                else
                    gradient.Rotation = 0
                end
                if not gradient.Parent then gradient.Parent = cache.Box.Full.Filled end
            elseif cache.Box.Full.Filled then
                cache.Box.Full.Filled.Visible = false
            end
        else
            cache.Box.Full.Square.Visible = false
            cache.Box.Full.Outline.Visible = false
            cache.Box.Full.Inline.Visible = false
            if cache.Box.Full.Filled then cache.Box.Full.Filled.Visible = false end
        end
    else
        cache.Box.Full.Square.Visible = false
        cache.Box.Full.Outline.Visible = false
        cache.Box.Full.Inline.Visible = false
        if cache.Box.Full.Filled then cache.Box.Full.Filled.Visible = false end
    end
    if ESPConfig.Bars.Health.Enable and humanoid then
        local targetHealth = M.clamp(humanoid.Health / humanoid.MaxHealth, 0, 1)
        local lastHealth = cache.Bars.Health.LastHealth or targetHealth
        local lerpedHealth = lastHealth + (targetHealth - lastHealth) * 0.05
        cache.Bars.Health.LastHealth = lerpedHealth
        local x = position.X - 7
        if cache.Bars.Health.Outline and cache.Bars.Health.Frame then
            cache.Bars.Health.Outline.Visible = true
            cache.Bars.Health.Outline.Position = U2.new(0, x - 1, 0, position.Y - S.GU:GetGuiInset().Y - 1)
            cache.Bars.Health.Outline.Size = U2.new(0, 5, 0, size.Y + 1.1)
            cache.Bars.Health.Outline.BackgroundTransparency = 0.2
            cache.Bars.Health.Frame.Visible = true
            cache.Bars.Health.Frame.Position = U2.new(0, 1, 0, (1 - lerpedHealth) * size.Y + 1)
            cache.Bars.Health.Frame.Size = U2.new(0, 3, 0, lerpedHealth * size.Y)
            cache.Bars.Health.Frame.BackgroundColor3 = ESPConfig.Bars.Health.Color1
        end
    else
        if cache.Bars.Health.Outline then cache.Bars.Health.Outline.Visible = false end
        if cache.Bars.Health.Frame then cache.Bars.Health.Frame.Visible = false end
    end
    if ESPConfig.Text.Enable then
        if cache.Text.Name then
            cache.Text.Name.Visible = ESPConfig.Text.Name.Enable
            if ESPConfig.Text.Name.Enable then
                cache.Text.Name.Position = U2.new(0, position.X + (size.X / 2) - (cache.Text.Name.AbsoluteSize.X / 2), 0, position.Y - S.GU:GetGuiInset().Y - 9)
                cache.Text.Name.Text = player.Name
                cache.Text.Name.TextColor3 = ESPConfig.Text.Name.Color
            end
        end
        if cache.Text.Tool then
            cache.Text.Tool.Visible = ESPConfig.Text.Tool.Enable
            if ESPConfig.Text.Tool.Enable then
                cache.Text.Tool.Position = U2.new(0, position.X + (size.X / 2) - (cache.Text.Tool.AbsoluteSize.X / 2), 0, position.Y - S.GU:GetGuiInset().Y + size.Y + 15)
                local tool = character:FindFirstChildOfClass("Tool")
                cache.Text.Tool.Text = tool and tool.Name or "none"
                cache.Text.Tool.TextColor3 = ESPConfig.Text.Tool.Color
            end
        end
        if cache.Text.Studs then
            cache.Text.Studs.Visible = ESPConfig.Text.Studs.Enable
            if ESPConfig.Text.Studs.Enable then
                cache.Text.Studs.Position = U2.new(0, position.X + (size.X / 2) - (cache.Text.Studs.AbsoluteSize.X / 2), 0, position.Y - S.GU:GetGuiInset().Y + size.Y + 5)
                local meters = (S.WS.CurrentCamera.CFrame.Position - rootPart.Position).Magnitude * 0.28
                cache.Text.Studs.Text = STR.fmt("[%.0fm]", meters)
                cache.Text.Studs.TextColor3 = ESPConfig.Text.Studs.Color
            end
        end
    else
        if cache.Text.Name then cache.Text.Name.Visible = false end
        if cache.Text.Tool then cache.Text.Tool.Visible = false end
        if cache.Text.Studs then cache.Text.Studs.Visible = false end
    end
end

for _, player in ipairs(S.PS:GetPlayers()) do
    if player ~= LP then
        render_esp(player)
    end
end
S.PS.PlayerAdded:Connect(function(player)
    if player ~= LP then
        render_esp(player)
    end
end)
S.PS.PlayerRemoving:Connect(function(player)
    if player ~= LP then
        clear_esp(player)
    end
end)

if ESPConnections.Heartbeat then ESPConnections.Heartbeat:Disconnect() end
ESPConnections.Heartbeat = HRT:Connect(function()
    for v, _ in pairs(ESPCache) do
        if v then
            update_esp(v)
        end
    end
end)

local NameESPGroup = Tabs.Visuals:AddRightGroupbox('>_<')
local ShowNameMethodConfig = {
    Mode = 'Display',
}

NameESPGroup:AddDropdown('ShowNameMethod', {
    Values = {'Display', 'Default', 'None'},
    Default = 'Display',
    Multi = false,
    Text = 'ShowNameMethod',
    Callback = function(v) ShowNameMethodConfig.Mode = v end
})

local function UpdateShowNameMethod(player)
    if player == LP then return end
    local char = player.Character
    if not char then return end
    local hum = char:FindFirstChildOfClass('Humanoid')
    if not hum then return end
    if ShowNameMethodConfig.Mode == 'None' then
        hum.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.None
        return
    end
    hum.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.Viewer
    hum.NameOcclusion = Enum.NameOcclusion.NoOcclusion
    hum.DisplayName = (ShowNameMethodConfig.Mode == 'Display' and player.DisplayName ~= '' and player.DisplayName) or player.Name
end

local function UpdateAllShowNameMethod()
    for _, p in ipairs(S.PS:GetPlayers()) do
        UpdateShowNameMethod(p)
    end
end

S.PS.PlayerAdded:Connect(function(p)
    p.CharacterAdded:Connect(function() UpdateShowNameMethod(p) end)
end)
for _, p in ipairs(S.PS:GetPlayers()) do
    if p.Character then UpdateShowNameMethod(p) end
    p.CharacterAdded:Connect(function() UpdateShowNameMethod(p) end)
end
HRT:Connect(UpdateAllShowNameMethod)

-- Unlock Camera Distance (Misc)


-- Сохраняем оригинальные значения при загрузке
G.originalPlayerMaxZoom = LP.CameraMaxZoomDistance
G.originalPlayerMinZoom = LP.CameraMinZoomDistance


-- SphereAura UI и логика
local SphereAuraSettings = {
    enabled = false,
    color1 = Color3.new(1, 1, 1),
    color2 = Color3.new(1, 1, 1),
    size = 10,
    lightEmission = 1
}
local currentAura

local function updateAura(prop)
    if not (currentAura and currentAura.Parent) then return end
    local swirl = currentAura:FindFirstChild("Attachment"):FindFirstChild("swirl")
    if not swirl then return end
    if prop == "color" or prop == nil then
        swirl.Color = ColorSequence.new({ColorSequenceKeypoint.new(0, SphereAuraSettings.color1), ColorSequenceKeypoint.new(1, SphereAuraSettings.color2)})
    end
    if prop == "size" or prop == nil then
        swirl.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, SphereAuraSettings.size), NumberSequenceKeypoint.new(1, SphereAuraSettings.size)})
    end
    if prop == "light" or prop == nil then
        swirl.LightEmission = SphereAuraSettings.lightEmission
    end
end

local function removePlayerAura()
    if currentAura and currentAura.Parent then currentAura:Destroy() end
    currentAura = nil
end

local function createPlayerAura(character)
    removePlayerAura()
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart") or character:WaitForChild("HumanoidRootPart", 3)
    if not humanoidRootPart then return end
    local auraBase = Instance.new("Part")
    auraBase.Size, auraBase.Transparency, auraBase.Anchored, auraBase.CanCollide, auraBase.Name, auraBase.Parent = Vector3.new(1, 1, 1), 1, false, false, "AuraBase", S.WS
    local weld = Instance.new("Weld")
    weld.Part0, weld.Part1, weld.C0, weld.Parent = humanoidRootPart, auraBase, CFrame.new(0, 0, 0), auraBase
    local attachment = Instance.new("Attachment")
    attachment.Parent = auraBase
    local swirlEmitter = Instance.new("ParticleEmitter")
    swirlEmitter.Name, swirlEmitter.Texture, swirlEmitter.Lifetime, swirlEmitter.Rate, swirlEmitter.RotSpeed, swirlEmitter.Speed = "swirl", "rbxassetid://10558425570", NumberRange.new(2), 150, NumberRange.new(200), NumberRange.new(0.01)
    swirlEmitter.SpreadAngle, swirlEmitter.VelocitySpread, swirlEmitter.Size, swirlEmitter.Transparency = Vector2.new(-360, 360), -360, NumberSequence.new({NumberSequenceKeypoint.new(0, SphereAuraSettings.size), NumberSequenceKeypoint.new(1, SphereAuraSettings.size)}), NumberSequence.new({NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.5006, 0.5), NumberSequenceKeypoint.new(1, 1)})
    swirlEmitter.Color, swirlEmitter.LightEmission, swirlEmitter.ZOffset, swirlEmitter.Orientation, swirlEmitter.LockedToPart, swirlEmitter.Parent = ColorSequence.new({ColorSequenceKeypoint.new(0, SphereAuraSettings.color1), ColorSequenceKeypoint.new(1, SphereAuraSettings.color2)}), SphereAuraSettings.lightEmission, -1, Enum.ParticleOrientation.VelocityPerpendicular, true, attachment
    currentAura = auraBase
end

local function applyPlayerAura()
    local character = LP.Character
    if not character then
        local characterAddedConnection
        if characterAddedConnection then characterAddedConnection:Disconnect() end
        characterAddedConnection = LP.CharacterAdded:Connect(function(newCharacter)
            if SphereAuraSettings.enabled then createPlayerAura(newCharacter) end
        end)
        return
    end
    createPlayerAura(character)
    if not characterAddedConnection then
        local characterAddedConnection
        characterAddedConnection = LP.CharacterAdded:Connect(function(newCharacter)
            if SphereAuraSettings.enabled then createPlayerAura(newCharacter) end
        end)
    end
end

getgenv().GetSphereAuraSettings = function() return SphereAuraSettings end

local SphereAuraGroup = Tabs.Visuals:AddRightGroupbox('>_<')
addToggleWithNotify(SphereAuraGroup, 'SphereAura', {
    Text = 'SphereAura',
    Default = false,
    Callback = function(v)
        SphereAuraSettings.enabled = v
        if v then
            applyPlayerAura()
        else
            removePlayerAura()
        end
    end
}):AddColorPicker('SphereAuraColor1', {
    Default = SphereAuraSettings.color1,
    Title = 'Color 1',
    Callback = function(val)
        SphereAuraSettings.color1 = val
        updateAura("color")
    end
}):AddColorPicker('SphereAuraColor2', {
    Default = SphereAuraSettings.color2,
    Title = 'Color 2',
    Callback = function(val)
        SphereAuraSettings.color2 = val
        updateAura("color")
    end
})

local SphereAuraSub = SphereAuraGroup:AddDependencyBox()
SphereAuraSub:AddSlider('SphereAuraSize', {
    Text = 'Size',
    Default = SphereAuraSettings.size,
    Min = 1,
    Max = 50,
    Rounding = 1,
    Callback = function(val)
        SphereAuraSettings.size = val
        updateAura("size")
    end
})
SphereAuraSub:AddSlider('SphereAuraLightEmission', {
    Text = 'LightEmission',
    Default = SphereAuraSettings.lightEmission,
    Min = 0,
    Max = 2,
    Rounding = 2,
    Callback = function(val)
        SphereAuraSettings.lightEmission = val
        updateAura("light")
    end
})
SphereAuraSub:SetupDependencies({{Toggles.SphereAura, true}})

-- CircleAura UI и логика
local CircleAuraSettings = {
    enabled = false,
    beamColor = Color3.new(1, 1, 1),
    circleColor = Color3.new(1, 1, 1),
    lightEmission = 0.8,
    circleTexture = "rbxassetid://8920246243"
}
local currentCircleAura

local function removeCircleAura()
    if currentCircleAura and currentCircleAura.Parent then currentCircleAura:Destroy() end
    currentCircleAura = nil
end

local function updateCircleAura(prop)
    if not (currentCircleAura and currentCircleAura.Parent) then return end
    for _, obj in pairs(currentCircleAura:GetDescendants()) do
        if (prop == nil or prop == "beamColor") and obj:IsA("Beam") then
            obj.Color = ColorSequence.new(CircleAuraSettings.beamColor)
        end
        if (prop == nil or prop == "circleColor") and obj:IsA("ParticleEmitter") and obj.Name == "Circle" then
            obj.Color = ColorSequence.new({ColorSequenceKeypoint.new(0, CircleAuraSettings.circleColor), ColorSequenceKeypoint.new(1, CircleAuraSettings.circleColor)})
        end
        if (prop == nil or prop == "lightEmission") and (obj:IsA("Beam") or obj:IsA("ParticleEmitter")) then
            obj.LightEmission = CircleAuraSettings.lightEmission
        end
        if (prop == nil or prop == "circleTexture") and obj:IsA("ParticleEmitter") and obj.Name == "Circle" then
            obj.Texture = CircleAuraSettings.circleTexture
        end
    end
end

local function createCircleAura(character)
    removeCircleAura()
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart") or character:WaitForChild("HumanoidRootPart", 3)
    if not humanoidRootPart then return end
    local auraBase = Instance.new("Part")
    auraBase.Size, auraBase.Transparency, auraBase.Anchored, auraBase.CanCollide, auraBase.Name, auraBase.Parent = Vector3.new(1, 1, 1), 1, true, false, "CircleAuraBase", S.WS
    auraBase.CFrame = CFrame.new(humanoidRootPart.Position) * CFrame.new(0, -0.15, 0)
    local positionUpdateConnection
    positionUpdateConnection = HRT:Connect(function()
        if humanoidRootPart and humanoidRootPart.Parent and auraBase and auraBase.Parent then
            auraBase.CFrame = CFrame.new(humanoidRootPart.Position) * CFrame.new(0, -0.15, 0)
        else
            if positionUpdateConnection then positionUpdateConnection:Disconnect() end
        end
    end)
    auraBase.AncestryChanged:Connect(function() if not auraBase.Parent and positionUpdateConnection then positionUpdateConnection:Disconnect() end end)

    local mainAttachment = Instance.new("Attachment")
    mainAttachment.Name, mainAttachment.Position, mainAttachment.Parent = "Main", Vector3.new(0, -2.75, 0), auraBase
    local circleEmitter = Instance.new("ParticleEmitter")
    circleEmitter.Name, circleEmitter.Texture, circleEmitter.Lifetime, circleEmitter.Rate, circleEmitter.RotSpeed, circleEmitter.Speed = "Circle", CircleAuraSettings.circleTexture, NumberRange.new(9), 0.333, NumberRange.new(120), NumberRange.new(0.001)
    circleEmitter.Size, circleEmitter.Transparency, circleEmitter.Color, circleEmitter.LightEmission, circleEmitter.ZOffset, circleEmitter.Orientation, circleEmitter.LockedToPart, circleEmitter.Parent = NumberSequence.new({NumberSequenceKeypoint.new(0, 3), NumberSequenceKeypoint.new(1, 3)}), NumberSequence.new({NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.1, 0), NumberSequenceKeypoint.new(0.5, 0), NumberSequenceKeypoint.new(0.6256, 0.0875), NumberSequenceKeypoint.new(0.7691, 0.3875), NumberSequenceKeypoint.new(0.8677, 0.7125), NumberSequenceKeypoint.new(0.9230, 0.875), NumberSequenceKeypoint.new(0.9552, 0.9375), NumberSequenceKeypoint.new(1, 0.975)}), ColorSequence.new({ColorSequenceKeypoint.new(0, CircleAuraSettings.circleColor), ColorSequenceKeypoint.new(1, CircleAuraSettings.circleColor)}), CircleAuraSettings.lightEmission, 0.05, Enum.ParticleOrientation.VelocityPerpendicular, true, mainAttachment

    local attachOne, attachTwo = Instance.new("Attachment"), Instance.new("Attachment")
    attachOne.Name, attachOne.Position, attachOne.Parent = "One", Vector3.new(0, -2.8, 2.6), auraBase
    attachTwo.Name, attachTwo.Position, attachTwo.Parent = "Two", Vector3.new(0, -2.8, -2.6), auraBase
    local beamOne = Instance.new("Beam")
    beamOne.Name, beamOne.Texture, beamOne.TextureSpeed, beamOne.TextureLength, beamOne.Width0, beamOne.Width1, beamOne.CurveSize0, beamOne.CurveSize1, beamOne.Segments, beamOne.LightEmission, beamOne.Transparency, beamOne.Color, beamOne.Attachment0, beamOne.Attachment1, beamOne.Parent = "One", "rbxassetid://8920073892", -0.3, 0.5, 4, 4, -3.5, 3.5, 25, CircleAuraSettings.lightEmission, NumberSequence.new({NumberSequenceKeypoint.new(0, 0.3), NumberSequenceKeypoint.new(1, 0.3)}), ColorSequence.new(CircleAuraSettings.beamColor), attachOne, attachTwo, auraBase
    local beamTwo = Instance.new("Beam")
    beamTwo.Name, beamTwo.Texture, beamTwo.TextureSpeed, beamTwo.TextureLength, beamTwo.Width0, beamTwo.Width1, beamTwo.CurveSize0, beamTwo.CurveSize1, beamTwo.Segments, beamTwo.LightEmission, beamTwo.Transparency, beamTwo.Color, beamTwo.Attachment0, beamTwo.Attachment1, beamTwo.Parent = "Two", "rbxassetid://8920073892", 0.3, 0.5, 4, 4, 3.5, -3.5, 25, CircleAuraSettings.lightEmission, NumberSequence.new({NumberSequenceKeypoint.new(0, 0.3), NumberSequenceKeypoint.new(1, 0.3)}), ColorSequence.new(CircleAuraSettings.beamColor), attachOne, attachTwo, auraBase

    local attachThree, attachFour = Instance.new("Attachment"), Instance.new("Attachment")
    attachThree.Name, attachThree.Position, attachThree.Parent = "Three", Vector3.new(0, -2.7, 0), auraBase
    attachFour.Name, attachFour.Position, attachFour.Parent = "Four", Vector3.new(0, 6, 0), auraBase
    local beamThree = Instance.new("Beam")
    beamThree.Name, beamThree.Texture, beamThree.TextureSpeed, beamThree.TextureLength, beamThree.Width0, beamThree.Width1, beamThree.Segments, beamThree.LightEmission, beamThree.Transparency, beamThree.Color, beamThree.FaceCamera, beamThree.Attachment0, beamThree.Attachment1, beamThree.Parent = "Three", "rbxassetid://9020147050", 0.3, 0.1, 5, 6, 5, CircleAuraSettings.lightEmission, NumberSequence.new({NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.1, 1), NumberSequenceKeypoint.new(0.4, 0.4), NumberSequenceKeypoint.new(1, 1)}), ColorSequence.new(CircleAuraSettings.beamColor), true, attachThree, attachFour, auraBase
    local beamFour = Instance.new("Beam")
    beamFour.Name, beamFour.Texture, beamFour.TextureSpeed, beamFour.TextureLength, beamFour.Width0, beamFour.Width1, beamFour.Segments, beamFour.LightEmission, beamFour.Transparency, beamFour.Color, beamFour.FaceCamera, beamFour.Attachment0, beamFour.Attachment1, beamFour.Parent = "Four", "rbxassetid://8984452855", 0.06, 0.4, 5, 6, 5, CircleAuraSettings.lightEmission, NumberSequence.new({NumberSequenceKeypoint.new(0, 0.3), NumberSequenceKeypoint.new(1, 1)}), ColorSequence.new(CircleAuraSettings.beamColor), true, attachThree, attachFour, auraBase
    local beamFive = Instance.new("Beam")
    beamFive.Name, beamFive.Texture, beamFive.TextureSpeed, beamFive.TextureLength, beamFive.Width0, beamFive.Width1, beamFive.Segments, beamFive.LightEmission, beamFive.Transparency, beamFive.Color, beamFive.FaceCamera, beamFive.Attachment0, beamFive.Attachment1, beamFive.Parent = "Five", "http://www.roblox.com/asset/?id=4390493166", 0.2, 0.15, 4, 4, 5, CircleAuraSettings.lightEmission, NumberSequence.new({NumberSequenceKeypoint.new(0, 0.3), NumberSequenceKeypoint.new(1, 1)}), ColorSequence.new(CircleAuraSettings.beamColor), true, attachThree, attachFour, auraBase

    currentCircleAura = auraBase
end

local function applyCircleAura()
    local character = LP.Character
    if not character then
        local circleAuraConnection
        if circleAuraConnection then circleAuraConnection:Disconnect() end
        circleAuraConnection = LP.CharacterAdded:Connect(function(newCharacter)
            if CircleAuraSettings.enabled then createCircleAura(newCharacter) end
        end)
        return
    end
    createCircleAura(character)
    if not circleAuraConnection then
        local circleAuraConnection
        circleAuraConnection = LP.CharacterAdded:Connect(function(newCharacter)
            if CircleAuraSettings.enabled then createCircleAura(newCharacter) end
        end)
    end
end

getgenv().GetCircleAuraSettings = function() return CircleAuraSettings end

-- UI
addToggleWithNotify(SphereAuraGroup, 'CircleAura', {
    Text = 'Aura',
    Default = false,
    Callback = function(v)
        CircleAuraSettings.enabled = v
        if v then
            applyCircleAura()
        else
            removeCircleAura()
        end
    end
}):AddColorPicker('CircleAuraBeamColor', {
    Default = CircleAuraSettings.beamColor,
    Title = 'Beam Color',
    Callback = function(val)
        CircleAuraSettings.beamColor = val
        updateCircleAura('beamColor')
    end
}):AddColorPicker('CircleAuraCircleColor', {
    Default = CircleAuraSettings.circleColor,
    Title = 'Circle Color',
    Callback = function(val)
        CircleAuraSettings.circleColor = val
        updateCircleAura('circleColor')
    end
})

local CircleAuraSub = SphereAuraGroup:AddDependencyBox()
CircleAuraSub:AddSlider('CircleAuraLightEmission', {
    Text = 'Emission',
    Default = CircleAuraSettings.lightEmission,
    Min = 0,
    Max = 2,
    Rounding = 2,
    Callback = function(val)
        CircleAuraSettings.lightEmission = val
        updateCircleAura('lightEmission')
    end
})
CircleAuraSub:AddDropdown('CircleAuraCircleTexture', {
    Text = 'CircleTexture',
    Values = {
        '8920246243',
        '10365549270',
        '5726444189',
        '1266170131',
        '12363692255',
        '12363692920',
    },
    Default = '8920246243',
    Callback = function(val)
        CircleAuraSettings.circleTexture = 'rbxassetid://' .. val
        updateCircleAura('circleTexture')
    end
})
CircleAuraSub:SetupDependencies({{Toggles.CircleAura, true}})

-- ChinaHat UI и логика
local ChinaHatSettings = {
    enabled = false,
    minCameraDistance = 1,
    hatTransparency = 0.35,
    circleTransparency = 1,
    height = 0.75,
    radius = 5,
    sides = 25,
    rainbow = false,
    color = Color3.fromRGB(255, 255, 255),
    offset = Vector3.new(0, 0.75, 0)
}

local ChinaHatGroup = Tabs.Visuals:AddLeftGroupbox('>_<')
addToggleWithNotify(ChinaHatGroup, 'ChinaHatEnabled', {
    Text = 'ChinaHat',
    Default = ChinaHatSettings.enabled,
    Callback = function(v)
        ChinaHatSettings.enabled = v
    end
}):AddColorPicker('ChinaHatColor', {
    Default = ChinaHatSettings.color,
    Title = 'Color',
    Callback = function(val)
        ChinaHatSettings.color = val
    end
})
ChinaHatGroup:AddSlider('ChinaHatHeight', {
    Text = 'Height',
    Default = ChinaHatSettings.height,
    Min = 0.1,
    Max = 3,
    Rounding = 2,
    Callback = function(val)
        ChinaHatSettings.height = val
    end
})
ChinaHatGroup:AddSlider('ChinaHatRadius', {
    Text = 'Radius',
    Default = ChinaHatSettings.radius,
    Min = 1,
    Max = 10,
    Rounding = 2,
    Callback = function(val)
        ChinaHatSettings.radius = val
    end
})
ChinaHatGroup:AddToggle('ChinaHatRainbow', {
    Text = 'Rainbow',
    Default = ChinaHatSettings.rainbow,
    Callback = function(v)
        ChinaHatSettings.rainbow = v
    end
})

-- ChinaHat rendering logic
local ChinaHatDrawings = {}
local tau = M.rad(360) -- или просто 2*math.pi
for i = 1, ChinaHatSettings.sides do
    ChinaHatDrawings[i] = {Drawing.new('Line'), Drawing.new('Triangle')}
    ChinaHatDrawings[i][1].ZIndex = 2
    ChinaHatDrawings[i][1].Thickness = 2
    ChinaHatDrawings[i][2].ZIndex = 1
    ChinaHatDrawings[i][2].Filled = true
end

RND:Connect(function()
    local pass = ChinaHatSettings.enabled and LP.Character and LP.Character:FindFirstChild('Head') and (Cam.CFrame.p - Cam.Focus.p).magnitude > ChinaHatSettings.minCameraDistance and LP.Character:FindFirstChildOfClass('Humanoid') and LP.Character:FindFirstChildOfClass('Humanoid').Health > 0
    for i = 1, #ChinaHatDrawings do
        local line, triangle = ChinaHatDrawings[i][1], ChinaHatDrawings[i][2]
        if pass then
            local color = ChinaHatSettings.rainbow and Color3.fromHSV((tick() % 5 / 5 - (i / #ChinaHatDrawings)) % 1, 0.5, 1) or ChinaHatSettings.color
            local pos = LP.Character.Head.Position + ChinaHatSettings.offset
            local topWorld = pos + Vector3.new(0, ChinaHatSettings.height, 0)
            local last, next = (i / ChinaHatSettings.sides) * tau, ((i + 1) / ChinaHatSettings.sides) * tau
            local lastWorld = pos + (Vector3.new(M.cos(last), 0, M.sin(last)) * ChinaHatSettings.radius)
            local nextWorld = pos + (Vector3.new(M.cos(next), 0, M.sin(next)) * ChinaHatSettings.radius)
            local lastScreen = Cam:WorldToViewportPoint(lastWorld)
            local nextScreen = Cam:WorldToViewportPoint(nextWorld)
            local topScreen = Cam:WorldToViewportPoint(topWorld)
            line.From = Vector2.new(lastScreen.X, lastScreen.Y)
            line.To = Vector2.new(nextScreen.X, nextScreen.Y)
            line.Color = color
            line.Transparency = ChinaHatSettings.circleTransparency
            line.Visible = true
            triangle.PointA = Vector2.new(topScreen.X, topScreen.Y)
            triangle.PointB = line.From
            triangle.PointC = line.To
            triangle.Color = color
            triangle.Transparency = ChinaHatSettings.hatTransparency
            triangle.Visible = true
        else
            line.Visible = false
            triangle.Visible = false
        end
    end
end)

-- === World Controller UI (LEFT) ===
local WorldGroup = Tabs.Visuals:AddLeftGroupbox('>_<')

local Lighting = S.LS
local function ensureCC()
    local cc = Lighting:FindFirstChildOfClass('ColorCorrectionEffect')
    if not cc then
        cc = Instance.new('ColorCorrectionEffect')
        cc.Parent = Lighting
        cc.Enabled = true
    end
    return cc
end
local cc = ensureCC()

local WorldConfig = {
    FogEnabled = false,
    FogColor = Color3.new(1,1,1),
    FogStart = Lighting.FogStart or 0,
    FogEnd = Lighting.FogEnd or 100,
    Shadows = false,
    ShadowColor = Lighting.ShadowColor or Color3.new(0,0,0),
    Time = Lighting.ClockTime or 12,
    Saturation = cc.Saturation or 0,
    Brightness = cc.Brightness or 0
}

local function applyWorld()
    if WorldConfig.FogEnabled then
        Lighting.FogStart = WorldConfig.FogStart
        Lighting.FogEnd = WorldConfig.FogEnd
        Lighting.FogColor = WorldConfig.FogColor
    else
        Lighting.FogStart = 1e6
        Lighting.FogEnd = 1e6
        -- Не трогаем Lighting.FogColor
    end
    Lighting.GlobalShadows = WorldConfig.Shadows
    Lighting.ShadowColor = WorldConfig.ShadowColor
    Lighting.ClockTime = WorldConfig.Time
    local cc = ensureCC()
    cc.Saturation = WorldConfig.Saturation
    cc.Brightness = WorldConfig.Brightness
end

local FogToggle = addToggleWithNotify(WorldGroup, 'FogEnabled', {
    Text = 'Fog',
    Default = false,
    Callback = function(v) WorldConfig.FogEnabled = v; applyWorld() end
})
FogToggle:AddColorPicker('FogColor', {
    Default = Color3.new(1,1,1),
    Title = 'Col',
    Callback = function(val) WorldConfig.FogColor = val; applyWorld() end
})
WorldGroup:AddSlider('FogStart', {
    Text = 'FStart',
    Default = WorldConfig.FogStart,
    Min = 0, Max = 10000, Rounding = 1,
    Callback = function(val) WorldConfig.FogStart = val; applyWorld() end
})
WorldGroup:AddSlider('FogEnd', {
    Text = 'FEnd',
    Default = WorldConfig.FogEnd,
    Min = 0, Max = 10000, Rounding = 1,
    Callback = function(val) WorldConfig.FogEnd = val; applyWorld() end
})
local ShadowsToggle = WorldGroup:AddToggle('Shadows', {
    Text = 'Shadows',
    Default = false,
    Callback = function(v) WorldConfig.Shadows = v; applyWorld() end
})
WorldGroup:AddSlider('Time', {
    Text = 'Time',
    Default = WorldConfig.Time,
    Min = 0, Max = 24, Rounding = 1,
    Callback = function(val) WorldConfig.Time = val; applyWorld() end
})
WorldGroup:AddSlider('Saturation', {
    Text = 'Sat',
    Default = WorldConfig.Saturation,
    Min = -1, Max = 1, Rounding = 1,
    Callback = function(val) WorldConfig.Saturation = val; applyWorld() end
})
WorldGroup:AddSlider('Brightness', {
    Text = 'Brt',
    Default = WorldConfig.Brightness,
    Min = -1, Max = 1, Rounding = 1,
    Callback = function(val) WorldConfig.Brightness = val; applyWorld() end
})

-- === LightingType Controller (RIGHT) ===
local LightingTypeGroup = Tabs.Visuals:AddRightGroupbox('>_<')
local LightingTypeList = {"Voxel", "ShadowMap", "Future"}
local LightingTypeEnum = {
    Voxel = Enum.Technology.Voxel,
    ShadowMap = Enum.Technology.ShadowMap,
    Future = Enum.Technology.Future
}
LightingTypeGroup:AddDropdown('LightingType', {
    Text = 'LightingType',
    Values = LightingTypeList,
    Default = 'Voxel',
    Callback = function(val)
        local tech = LightingTypeEnum[val]
        if tech then
            S.LS.Technology = tech
        end
    end
})
-- При запуске выставить первый режим
S.LS.Technology = LightingTypeEnum[LightingTypeList[1]]

-- === Speedhack (Player tab, right) ===
local SpeedhackGroup = Tabs.Player:AddRightGroupbox('>_<')
local SpeedhackConfig = {
    Enabled = false, -- toggle
    Active = false,  -- keybind
    Speed = 50
}
local speedHackConnection
local function updateSpeedHack(character)
    if not character then return end
    local rootPart = character:WaitForChild('HumanoidRootPart')
    local humanoid = character:WaitForChild('Humanoid')
    if speedHackConnection then speedHackConnection:Disconnect() end
    speedHackConnection = HRT:Connect(function(dt)
        if SpeedhackConfig.Enabled and SpeedhackConfig.Active then
            local move = humanoid.MoveDirection
            if move.Magnitude > 0 then
                rootPart.CFrame = rootPart.CFrame + (move.Unit * SpeedhackConfig.Speed * dt)
            end
        end
    end)
end
addToggleWithNotify(SpeedhackGroup, 'SpeedhackEnabled', {
    Text = 'Speedhack',
    Default = false,
    Callback = function(v)
        SpeedhackConfig.Enabled = v
        if v then
            updateSpeedHack(LP.Character)
        else
            SpeedhackConfig.Active = false
            if speedHackConnection then speedHackConnection:Disconnect() speedHackConnection = nil end
        end
    end
})
:AddKeyPicker('SpeedhackKey', {
    Default = 'None',
    Text = 'Speedhack',
    NoUI = false,
    Callback = function()
        if not SpeedhackConfig.Enabled then return end
        SpeedhackConfig.Active = not SpeedhackConfig.Active
    end
})

local speedInput = SpeedhackGroup:AddInput('SpeedhackSpeedBox', {
    Text = 'Speed',
    Default = tostring(SpeedhackConfig.Speed),
    Numeric = true,
    Finished = true,
    Callback = function(val)
        local num = tonumber(val)
        if num then
            num = M.clamp(num, 1, 2000000)
            SpeedhackConfig.Speed = num
        end
    end
})

LP.CharacterAdded:Connect(function(char)
    if SpeedhackConfig.Enabled then
        updateSpeedHack(char)
    end
end)

-- === Fly (Player tab, left) ===
local FlyGroup = Tabs.Player:AddLeftGroupbox('>_<')
local FlyConfig = {
    Enabled = false, -- toggle (мастер)
    Active = false,  -- keybind (активность)
    Speed = 1,       -- множитель (1x = 50 studs/sec)
    Keybind = Enum.KeyCode.F
}
local FlyLoop = nil
local function setNoClip(character, state)
    if not character then return end
    for _, part in ipairs(character:GetDescendants()) do
        if part:IsA('BasePart') then
            if state then
                if not part:GetAttribute('OriginalCollision') then
                    part:SetAttribute('OriginalCollision', part.CanCollide)
                    part:SetAttribute('OriginalTouch', part.CanTouch)
                    if part:GetAttribute('CanQuery') ~= nil then
                        part:SetAttribute('OriginalQuery', part.CanQuery)
                    end
                end
                part.CanCollide = false
                part.CanTouch = false
                part.CanQuery = false
            else
                if part:GetAttribute('OriginalCollision') ~= nil then
                    part.CanCollide = part:GetAttribute('OriginalCollision')
                    part.CanTouch = part:GetAttribute('OriginalTouch')
                    if part:GetAttribute('OriginalQuery') ~= nil then
                        part.CanQuery = part:GetAttribute('OriginalQuery')
                    end
                    part:SetAttribute('OriginalCollision', nil)
                    part:SetAttribute('OriginalTouch', nil)
                    part:SetAttribute('OriginalQuery', nil)
                end
            end
        end
    end
end
local function updateFly(character)
    if FlyLoop then FlyLoop:Disconnect() FlyLoop = nil end
    if not character then return end
    if not (FlyConfig.Enabled and FlyConfig.Active) then return end
    setNoClip(character, true)
    FlyLoop = SND:Connect(function()
        local char = LP.Character
        if not char then return end
        setNoClip(char, true)
        local hrp = char:FindFirstChild('HumanoidRootPart')
        local hum = char:FindFirstChild('Humanoid')
        if not hrp or not hum then return end
        local speed = FlyConfig.Speed * 50
        local velocity = Vector3.new(0, 0, 0)
        if S.UIS:IsKeyDown(Enum.KeyCode.Space) then velocity = velocity + Vector3.new(0, speed, 0) end
        if S.UIS:IsKeyDown(Enum.KeyCode.LeftControl) then velocity = velocity + Vector3.new(0, -speed, 0) end
        if S.UIS:IsKeyDown(Enum.KeyCode.W) then velocity = velocity + (Cam.CFrame.LookVector * speed) end
        if S.UIS:IsKeyDown(Enum.KeyCode.A) then velocity = velocity + (Cam.CFrame.RightVector * -speed) end
        if S.UIS:IsKeyDown(Enum.KeyCode.S) then velocity = velocity + (Cam.CFrame.LookVector * -speed) end
        if S.UIS:IsKeyDown(Enum.KeyCode.D) then velocity = velocity + (Cam.CFrame.RightVector * speed) end
        hrp.Velocity = velocity
        hum:ChangeState('Freefall')
    end)
end
local function stopFly()
    if FlyLoop then FlyLoop:Disconnect() FlyLoop = nil end
    local char = LP.Character
    setNoClip(char, false)
    if char then
        local hrp = char:FindFirstChild('HumanoidRootPart')
        local hum = char:FindFirstChild('Humanoid')
        if hrp then
            hrp.Velocity = Vector3.new(0, -2, 0)
            local tempConn
            tempConn = SND:Connect(function()
                if not hrp or not hrp.Parent then tempConn:Disconnect() return end
                hrp.Velocity = Vector3.new(0, hrp.Velocity.Y, 0)
                tempConn:Disconnect()
            end)
        end
        if hum then hum:ChangeState('Landing') end
    end
end
local function setFlyActive(state)
    FlyConfig.Active = state
    if FlyConfig.Enabled and FlyConfig.Active then
        updateFly(LP.Character)
    else
        stopFly()
    end
end
addToggleWithNotify(FlyGroup, 'FlyEnabled', {
    Text = 'Fly',
    Default = false,
    Callback = function(v)
        FlyConfig.Enabled = v
        if not v then
            setFlyActive(false)
        end
        if v and FlyConfig.Active then
            updateFly(LP.Character)
        end
    end
})
:AddKeyPicker('FlyKey', {
    Default = 'None',
    Text = 'Fly',
    NoUI = false,
    Callback = function()
        if not FlyConfig.Enabled then return end
        setFlyActive(not FlyConfig.Active)
    end
})
FlyGroup:AddInput('FlySpeed', {
    Text = 'Speed',
    Default = tostring(FlyConfig.Speed),
    Numeric = true,
    Finished = true,
    Callback = function(val)
        local num = tonumber(val)
        if num then
            num = M.clamp(num, 0.1, 100)
            FlyConfig.Speed = num
        end
    end
})
LP.CharacterAdded:Connect(function(char)
    if FlyConfig.Enabled and FlyConfig.Active then
        updateFly(char)
    end
end)

-- === NoRecoil (Misc tab, отдельная секция) ===
local NoRecoilGroup = Tabs.Misc:AddLeftGroupbox('>_<')

local noRecoilHook, originalNewIndex
local noRecoilEnabled = false

local function isframework(scriptInstance)
    return tostring(scriptInstance) == "Framework"
end

local function checkArgs(instance, index)
    return STR.lower(tostring(instance)):find("camera") and tostring(index) == "CFrame"
end

local function enableNoRecoil()
    if noRecoilHook then return end
    originalNewIndex = originalNewIndex or hookmetamethod(game, "__newindex", function(self, index, value)
        local callingScr = getcallingscript and getcallingscript() or nil
        if callingScr and isframework(callingScr) and checkArgs(self, index) then
            return
        end
        return originalNewIndex(self, index, value)
    end)
    noRecoilHook = true
end

local function disableNoRecoil()
    if not noRecoilHook then return end
    -- Снимаем хук: возвращаем оригинальный __newindex
    if originalNewIndex then
        hookmetamethod(game, "__newindex", originalNewIndex)
    end
    noRecoilHook = nil
end

addToggleWithNotify(NoRecoilGroup, 'No Recoil', {
    Text = 'NoRecoil',
    Default = false,
    Callback = function(v)
        noRecoilEnabled = v
        if v then
            enableNoRecoil()
        else
            disableNoRecoil()
        end
    end,
    Tooltip = '>_<'
})

-- === NoJumpCD (Misc tab, правая секция) ===
local NoJumpCDGroup = Tabs.Misc:AddRightGroupbox('>_<')

local noJumpCDHook, originalNewIndexJump, currentNoJumpCDHook
local noJumpCDEnabled = false

local function enableNoJumpCD()
    if noJumpCDHook then return end
    local IsA = game.IsA
    -- Сохраняем оригинальный только один раз
    if not originalNewIndexJump then
        originalNewIndexJump = hookmetamethod(game, "__newindex", function(self, Index, Value)
            return originalNewIndexJump(self, Index, Value)
        end)
    end
    -- Ставим кастомный хук, всегда используя оригинальный
    currentNoJumpCDHook = hookmetamethod(game, "__newindex", function(self, Index, Value)
        if not checkcaller() and IsA(self, "Humanoid") and Index == "JumpPower" then
            return
        end
        return originalNewIndexJump(self, Index, Value)
    end)
    noJumpCDHook = true
end

local function disableNoJumpCD()
    if not noJumpCDHook then return end
    if originalNewIndexJump then
        hookmetamethod(game, "__newindex", originalNewIndexJump)
    end
    noJumpCDHook = nil
    currentNoJumpCDHook = nil
end

addToggleWithNotify(NoJumpCDGroup, 'No Jump CD', {
    Text = 'NoJumpCD',
    Default = false,
    Callback = function(v)
        noJumpCDEnabled = v
        if v then
            enableNoJumpCD()
        else
            disableNoJumpCD()
        end
    end,
    Tooltip = '>_<'
})

NoJumpCDGroup:AddButton({
    Text = 'DestroySeats',
    Func = function()
        local count = 0
        for _, obj in ipairs(S.WS:GetDescendants()) do
            if obj:IsA('Seat') or obj:IsA('VehicleSeat') then
                obj:Destroy()
                count = count + 1
            end
        end
        Library:Notify('>_<', 3)
    end,
    Tooltip = '>_<'
})

-- === AntiInertia (Misc tab, отдельная правая секция) ===
local AntiInertiaGroup = Tabs.Misc:AddRightGroupbox('>_<')

local AntiInertiaSettings = {
    Enabled = false,
    Speed = {
        Ground = 0.3,
        Air = 0.3
    },
    NoInertia = true
}

local antiInertiaConnection = nil

local function ToggleAntiInertia(state)
    AntiInertiaSettings.Enabled = state
    if antiInertiaConnection then
        antiInertiaConnection:Disconnect()
        antiInertiaConnection = nil
    end
    if state then
        antiInertiaConnection = HRT:Connect(function()
            if not AntiInertiaSettings.Enabled then return end
            local character = LP.Character
            if not character or not character:FindFirstChild("HumanoidRootPart") then return end
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if not humanoid then return end
            local rootPart = character.HumanoidRootPart
            local moveDir = humanoid.MoveDirection
            if moveDir.Magnitude > 0 then
                local speedMult = (humanoid:GetState() == Enum.HumanoidStateType.Freefall or humanoid:GetState() == Enum.HumanoidStateType.Jumping)
                    and AntiInertiaSettings.Speed.Air or AntiInertiaSettings.Speed.Ground
                local newVel = moveDir * speedMult * 50
                if AntiInertiaSettings.NoInertia then
                    rootPart.Velocity = Vector3.new(newVel.X, rootPart.Velocity.Y, newVel.Z)
                else
                    local curVel = rootPart.Velocity
                    rootPart.Velocity = Vector3.new(
                        curVel.X + (newVel.X - curVel.X) * 0.5,
                        rootPart.Velocity.Y,
                        curVel.Z + (newVel.Z - curVel.Z) * 0.5
                    )
                end
            elseif AntiInertiaSettings.NoInertia then
                rootPart.Velocity = Vector3.new(0, rootPart.Velocity.Y, 0)
            end
        end)
    end
end

LP.CharacterAdded:Connect(function()
    if AntiInertiaSettings.Enabled then
        ToggleAntiInertia(true)
    end
end)

addToggleWithNotify(AntiInertiaGroup, 'Anti Inertia', {
    Text = 'AntiInertia',
    Default = false,
    Callback = function(v)
        ToggleAntiInertia(v)
    end,
    Tooltip = '>_<'
})

-- === Yaw Locker (Player tab, новая секция) ===
local YawLockerGroup = Tabs.Player:AddLeftGroupbox('>_<')

local YawLockerConfig = {
    Enabled = false,
    Angle = 0,
    Mode = 'Locked',
    Modes = {'Locked', 'Jitter', '3 Ways', '5 Ways'},
    AtTarget = false,
    DisableAutoRotate = false
}

-- Используем переменные из таблицы G для YawLocker

local function getYawAngles()
    local a = YawLockerConfig.Angle
    if YawLockerConfig.Mode == 'Locked' then
        return {a}
    elseif YawLockerConfig.Mode == 'Jitter' then
        return {a, -a}
    elseif YawLockerConfig.Mode == '3 Ways' then
        return {-a, 0, a}
    elseif YawLockerConfig.Mode == '5 Ways' then
        return {-a, -a/2, 0, a/2, a}
    end
    return {a}
end

local function applyYawLockerAutoRotate()
    local char = LP.Character
    if char then
        local hum = char:FindFirstChildOfClass('Humanoid')
        if hum then
            hum.AutoRotate = not YawLockerConfig.DisableAutoRotate
        end
    end
end

local function setYawLocker(state)
    YawLockerConfig.Enabled = state
    if G.yawLockerConnection then
        G.yawLockerConnection:Disconnect()
        G.yawLockerConnection = nil
    end
    G.yawJitterState = 1
    G.yawJitterTimer = 0
    applyYawLockerAutoRotate()
    if state then
        G.yawLockerConnection = RND:Connect(function(dt)
            local char = LP.Character
            if not char then return end
            local hrp = char:FindFirstChild('HumanoidRootPart')
            if not hrp then return end
            
            local myPos = hrp.Position
            local lookVector
            
            if YawLockerConfig.AtTarget then
                local target = getgenv().SilentAim and getgenv().SilentAim.currentTarget
                if target and target.Character and target.Character:FindFirstChild("HumanoidRootPart") then
                    local targetHrp = target.Character.HumanoidRootPart
                    local directionToTarget = (targetHrp.Position - myPos)
                    local baseYaw = M.atan2(directionToTarget.X, directionToTarget.Z)
                    
                    local angles = getYawAngles()
                    local finalYaw
                    
                    if YawLockerConfig.Mode == 'Jitter' then
                        G.yawJitterTimer = G.yawJitterTimer + dt
                        if G.yawJitterTimer > 0.1 then
                            G.yawJitterState = 3 - G.yawJitterState -- 1 <-> 2
                            G.yawJitterTimer = 0
                        end
                        finalYaw = baseYaw + M.rad(angles[G.yawJitterState])
                    elseif YawLockerConfig.Mode == '3 Ways' then
                         G.yawJitterTimer = G.yawJitterTimer + dt
                        if G.yawJitterTimer > 0.15 then
                            G.yawJitterState = G.yawJitterState % 3 + 1
                            G.yawJitterTimer = 0
                        end
                        finalYaw = baseYaw + M.rad(angles[G.yawJitterState])
                    elseif YawLockerConfig.Mode == '5 Ways' then
                         G.yawJitterTimer = G.yawJitterTimer + dt
                        if G.yawJitterTimer > 0.12 then
                            G.yawJitterState = G.yawJitterState % 5 + 1
                             G.yawJitterTimer = 0
                        end
                        finalYaw = baseYaw + M.rad(angles[G.yawJitterState])
                    else -- Locked
                        finalYaw = baseYaw + M.rad(angles[1])
                    end
                    
                    lookVector = Vector3.new(M.sin(finalYaw), 0, M.cos(finalYaw))
                end
            else -- Режим не AtTarget
                local angles = getYawAngles()
                local yaw
                if YawLockerConfig.Mode == 'Locked' then
                    yaw = M.rad(angles[1])
                elseif YawLockerConfig.Mode == 'Jitter' then
                    G.yawJitterTimer = G.yawJitterTimer + dt
                    if G.yawJitterTimer > 0.1 then
                        G.yawJitterState = 3 - G.yawJitterState -- 1 <-> 2
                        G.yawJitterTimer = 0
                    end
                    yaw = M.rad(angles[G.yawJitterState])
                elseif YawLockerConfig.Mode == '3 Ways' then
                    G.yawJitterTimer = G.yawJitterTimer + dt
                    if G.yawJitterTimer > 0.15 then
                        G.yawJitterState = G.yawJitterState % 3 + 1
                        G.yawJitterTimer = 0
                    end
                    yaw = M.rad(angles[G.yawJitterState])
                elseif YawLockerConfig.Mode == '5 Ways' then
                    G.yawJitterTimer = G.yawJitterTimer + dt
                    if G.yawJitterTimer > 0.12 then
                        G.yawJitterState = G.yawJitterState % 5 + 1
                        G.yawJitterTimer = 0
                    end
                    yaw = M.rad(angles[G.yawJitterState])
                else
                    yaw = M.rad(YawLockerConfig.Angle)
                end
                lookVector = Vector3.new(M.sin(yaw), 0, M.cos(yaw))
            end

            if lookVector then
                hrp.CFrame = CFrame.new(myPos, myPos + lookVector)
            end
        end)
    end
end

addToggleWithNotify(YawLockerGroup, 'YawLocker', {
    Text = 'YawLock',
    Default = false,
    Callback = function(v)
        setYawLocker(v)
    end,
    Tooltip = '>_<'
})

YawLockerGroup:AddDropdown('YawLockerMode', {
    Text = 'Mode',
    Values = YawLockerConfig.Modes,
    Default = 'Locked',
    Callback = function(val)
        YawLockerConfig.Mode = val
        yawJitterState = 1
        yawJitterTimer = 0
    end,
    Tooltip = '>_<'
})

YawLockerGroup:AddSlider('YawLockerAngle', {
    Text = 'Angle',
    Default = 0,
    Min = 0,
    Max = 360,
    Rounding = 0,
    Callback = function(val)
        YawLockerConfig.Angle = val
    end,
    Tooltip = '>_<'
})

YawLockerGroup:AddToggle('YawLockerAtTarget', {
    Text = 'AtTarget',
    Default = false,
    Callback = function(v)
        YawLockerConfig.AtTarget = v
    end,
    Tooltip = '>_<'
})

YawLockerGroup:AddToggle('YawLockerDisableAutoRotate', {
    Text = 'DisableAutoRotate',
    Default = false,
    Callback = function(v)
        YawLockerConfig.DisableAutoRotate = v
        applyYawLockerAutoRotate()
    end,
    Tooltip = '>_<'
})
LP.CharacterAdded:Connect(function(char)
    if YawLockerConfig.Enabled or YawLockerConfig.DisableAutoRotate then
        applyYawLockerAutoRotate()
    end
end)

-- === AnimBreaker (Player tab, новая секция) ===
local AnimBreakerGroup = Tabs.Player:AddRightGroupbox('>_<')

-- Глобальные переменные и настройки для AnimBreaker
getgenv().AnimBreakerSettings = {
    enabled = false,
    delayTime = 0.4,
    stepSize = 0.4,
    customAnimEnabled = false,
    customAnimId = "10714340543",
    persistAfterDeath = true -- Продолжать работу после смерти
}

getgenv().animBreakerTracks = {}
getgenv().animBreakerAnimatorConn = nil
getgenv().animBreakerHeartbeatConn = nil
getgenv().animBreakerCoroutine = nil
getgenv().customAnimCoroutine = nil
getgenv().deathConnection = nil
getgenv().respawnConnection = nil

-- Глобальные функции для AnimBreaker
function freezeAnimBreakerTrack(track)
    if not track or not track.IsPlaying then return end
    track:AdjustSpeed(0)
    getgenv().animBreakerTracks[track] = true
end

function restoreAnimations(character)
    local humanoid = character and character:FindFirstChildOfClass('Humanoid')
    if not humanoid then return end
    
    local animator = humanoid:FindFirstChildOfClass('Animator')
    if not animator then return end
    
    for _, track in pairs(animator:GetPlayingAnimationTracks()) do
        if getgenv().animBreakerTracks[track] then
            track:AdjustSpeed(1) -- Восстанавливаем нормальную скорость
            getgenv().animBreakerTracks[track] = nil
        end
    end
    
    if getgenv().animBreakerAnimatorConn then 
        getgenv().animBreakerAnimatorConn:Disconnect()
        getgenv().animBreakerAnimatorConn = nil
    end
    
    -- Восстанавливаем анимацию персонажа
    if humanoid:FindFirstChild("Animate") then
        humanoid.Animate.Disabled = false
    end
end

function playCustomAnimation(character, withLags)
    if not character then return end
    
    -- Проверяем, существует ли персонаж
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end
    
    -- Добавляем обработчик события смерти для перезапуска анимации
    if not getgenv().deathConnection and humanoid then
        getgenv().deathConnection = humanoid.Died:Connect(function()
            -- Сохраняем труп для проигрывания анимации на нем
            local deadCharacter = character
            
            -- Продолжаем проигрывать анимацию на трупе
            task.spawn(function()
                if getgenv().AnimBreakerSettings.customAnimEnabled and deadCharacter then
                    -- Пытаемся проиграть анимацию на трупе
                    local animator = deadCharacter:FindFirstChildOfClass("Humanoid") and 
                                    deadCharacter:FindFirstChildOfClass("Humanoid"):FindFirstChildOfClass("Animator")
                    
                    if animator then
                        local animation = Instance.new("Animation")
                        animation.AnimationId = "rbxassetid://" .. getgenv().AnimBreakerSettings.customAnimId
                        
                        pcall(function()
                            local track = animator:LoadAnimation(animation)
                            if track then
                                track:Play()
                                track.Looped = true
                            end
                        end)
                    end
                end
            end)
            
            -- Также настраиваем анимацию для нового персонажа после респавна
            task.spawn(function()
                task.wait(1) -- Даем время на респавн
                if getgenv().AnimBreakerSettings.customAnimEnabled then
                    local newCharacter = LP.Character or LP.CharacterAdded:Wait()
                    if newCharacter and newCharacter ~= deadCharacter then
                        playCustomAnimation(newCharacter, getgenv().AnimBreakerSettings.enabled)
                    end
                end
            end)
        end)
    end
    
    local animator = humanoid:FindFirstChildOfClass("Animator")
    if not animator then return end
    
    -- Отменяем предыдущую корутину
    if getgenv().customAnimCoroutine then
        task.cancel(getgenv().customAnimCoroutine)
        getgenv().customAnimCoroutine = nil
    end
    
    -- Создаем новую корутину для проигрывания анимации
    getgenv().customAnimCoroutine = task.spawn(function()
        -- Создаем анимацию
        local animation = Instance.new("Animation")
        animation.AnimationId = "rbxassetid://" .. getgenv().AnimBreakerSettings.customAnimId
        
        -- Загружаем анимацию
        local animTrack = nil
        pcall(function()
            animTrack = animator:LoadAnimation(animation)
        end)
        
        -- Если не удалось загрузить, пробуем еще раз
        if not animTrack then
            task.wait(0.1)
            pcall(function()
                animTrack = animator:LoadAnimation(animation)
            end)
        end
        
        -- Проигрываем анимацию, если удалось загрузить
        if animTrack then
            animTrack:Play()
            
            -- Если включен режим с лагами (AnimBreaker + CustomAnim)
            if withLags then
                -- Создаем эффект лагов, меняя скорость воспроизведения
                task.spawn(function()
                    while animTrack.IsPlaying and getgenv().AnimBreakerSettings.customAnimEnabled do
                        pcall(function()
                            -- Случайно меняем скорость для эффекта лагов
                            animTrack:AdjustSpeed(math.random(5, 20) / 10)
                            
                            -- Иногда перемещаем позицию воспроизведения
                            if math.random() > 0.5 then
                                animTrack.TimePosition = math.random() * animTrack.Length
                            end
                        end)
                        task.wait(math.random(5, 15) / 100)
                    end
                end)
            else
                -- Обычное воспроизведение без лагов
                animTrack:AdjustSpeed(1)
                animTrack.Looped = true
            end
        else
            -- Запасной метод через RemoteEvent
            pcall(function()
                if game:GetService("ReplicatedStorage"):FindFirstChild("MainEvent") then
                    local args = {
                        [1] = "PlayAnimation",
                        [2] = "rbxassetid://" .. getgenv().AnimBreakerSettings.customAnimId
                    }
                    game:GetService("ReplicatedStorage").MainEvent:FireServer(unpack(args))
                end
            end)
        end
    end)
end

function setupAnimBreakerCharacter(character)
    if not getgenv().AnimBreakerSettings.enabled then return end
    
    local humanoid = character:WaitForChild("Humanoid")
    local animator = humanoid:WaitForChild("Animator")
    
    table.clear(getgenv().animBreakerTracks)
    
    for _, track in pairs(animator:GetPlayingAnimationTracks()) do
        freezeAnimBreakerTrack(track)
    end
    
    if getgenv().animBreakerAnimatorConn then 
        getgenv().animBreakerAnimatorConn:Disconnect() 
    end
    
    getgenv().animBreakerAnimatorConn = animator.AnimationPlayed:Connect(freezeAnimBreakerTrack)
end

function toggleAnimBreaker(state)
    getgenv().AnimBreakerSettings.enabled = state
    
    if getgenv().animBreakerHeartbeatConn then 
        getgenv().animBreakerHeartbeatConn:Disconnect() 
        getgenv().animBreakerHeartbeatConn = nil 
    end
    
    if state then
        if LP.Character then
            setupAnimBreakerCharacter(LP.Character)
        end
        
        getgenv().animBreakerHeartbeatConn = HRT:Connect(function()
            for track in pairs(getgenv().animBreakerTracks) do
                if track and track.IsPlaying then
                    track:AdjustSpeed(0)
                else
                    getgenv().animBreakerTracks[track] = nil
                end
            end
        end)
        
        -- Запускаем отдельную корутину для обновления позиции анимации
        task.spawn(function()
            while getgenv().AnimBreakerSettings.enabled do
                for track in pairs(getgenv().animBreakerTracks) do
                    if track and track.IsPlaying then
                        pcall(function()
                            track.TimePosition = track.TimePosition + getgenv().AnimBreakerSettings.stepSize
                        end)
                    end
                end
                task.wait(getgenv().AnimBreakerSettings.delayTime)
            end
        end)
    else
        -- Восстанавливаем нормальные анимации при отключении
        if LP.Character then
            restoreAnimations(LP.Character)
        end
    end
    
    -- Обновляем состояние кастомной анимации при изменении AnimBreaker
    updateCustomAnimationState()
end

function toggleCustomAnimation(state)
    getgenv().AnimBreakerSettings.customAnimEnabled = state
    
    -- Очищаем предыдущие соединения смерти
    if getgenv().deathConnection then
        getgenv().deathConnection:Disconnect()
        getgenv().deathConnection = nil
    end
    
    if state and LP.Character then
        -- Запускаем анимацию с лагами или без в зависимости от состояния AnimBreaker
        local withLags = getgenv().AnimBreakerSettings.enabled
        playCustomAnimation(LP.Character, withLags)
    else
        -- Останавливаем корутину кастомной анимации
        if getgenv().customAnimCoroutine then
            task.cancel(getgenv().customAnimCoroutine)
            getgenv().customAnimCoroutine = nil
        end
        
        -- Останавливаем все анимации с нашим ID на всех персонажах в игре
        -- Это нужно, чтобы очистить анимации, которые могли остаться после смерти
        for _, player in ipairs(game:GetService("Players"):GetPlayers()) do
            if player.Character then
                local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
                if humanoid then
                    local animator = humanoid:FindFirstChildOfClass("Animator")
                    if animator then
                        for _, track in pairs(animator:GetPlayingAnimationTracks()) do
                            if track.Animation and track.Animation.AnimationId and 
                               track.Animation.AnimationId:find(getgenv().AnimBreakerSettings.customAnimId) then
                                track:Stop()
                            end
                        end
                    end
                end
            end
        end
    end
end

-- Обновляем состояние кастомной анимации при изменении AnimBreaker
function updateCustomAnimationState()
    if getgenv().AnimBreakerSettings.customAnimEnabled and LP.Character then
        -- Перезапускаем анимацию с новыми параметрами
        local withLags = getgenv().AnimBreakerSettings.enabled
        
        -- Останавливаем все текущие анимации
        local humanoid = LP.Character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            local animator = humanoid:FindFirstChildOfClass("Animator")
            if animator then
                for _, track in pairs(animator:GetPlayingAnimationTracks()) do
                    if track.Animation and track.Animation.AnimationId and 
                       track.Animation.AnimationId:find(getgenv().AnimBreakerSettings.customAnimId) then
                        track:Stop()
                    end
                end
            end
        end
        
        -- Запускаем с новыми параметрами
        playCustomAnimation(LP.Character, withLags)
    end
end

-- Глобальный обработчик появления персонажа
getgenv().respawnConnection = LP.CharacterAdded:Connect(function(character)
    -- Для AnimBreaker
    if getgenv().AnimBreakerSettings.enabled then
        setupAnimBreakerCharacter(character)
    end
    
    -- Для CustomAnim - запускаем анимацию после респавна
    if getgenv().AnimBreakerSettings.customAnimEnabled then
        -- Даем персонажу немного времени загрузиться
        task.wait(0.5)
        playCustomAnimation(character, getgenv().AnimBreakerSettings.enabled)
    end
end)

addToggleWithNotify(AnimBreakerGroup, 'AnimBreaker', {
    Text = 'AnimBreaker',
    Default = false,
    Callback = function(v)
        toggleAnimBreaker(v)
    end,
    Tooltip = '>_<'
})

-- Добавляем тогл для кастомной анимации
addToggleWithNotify(AnimBreakerGroup, 'CustomAnimation', {
    Text = 'CustomAnim',
    Default = false,
    Callback = function(v)
        toggleCustomAnimation(v)
    end,
    Tooltip = '>_<'
})

-- === RapidFireGunScript (Player tab, новая секция) ===
local RapidFireGunScriptGroup = Tabs.Player:AddRightGroupbox('>_<')

local Traced = { RapidFire = false }
local Orginal = {}
local rapidFireGunScriptConn = nil

local function enableRapidFireGunScript()
    if rapidFireGunScriptConn then rapidFireGunScriptConn:Disconnect() end
    
    -- Оптимизируем, добавив дебаунс и уменьшив частоту проверок
    local lastToolCheck = 0
    local toolCheckInterval = 0.2 -- Проверяем каждые 200мс вместо каждого кадра
    local currentTool = nil
    local isOptimizing = false
    
    rapidFireGunScriptConn = HRT:Connect(function()
        local now = tick()
        -- Проверяем оружие только через интервал или при смене оружия
        if now - lastToolCheck < toolCheckInterval and currentTool then return end
        
        lastToolCheck = now
        local tool = LP.Character and LP.Character:FindFirstChildOfClass('Tool')
        
        -- Если оружие не изменилось, не делаем повторную оптимизацию
        if tool == currentTool then return end
        currentTool = tool
        
        -- Если уже идет процесс оптимизации, не запускаем новый
        if isOptimizing then return end
        
        -- Запускаем оптимизацию в отдельном потоке, чтобы не влиять на FPS
        task.spawn(function()
            isOptimizing = true
            if tool and tool:FindFirstChild('GunScript') then
                for _, connection in ipairs(getconnections(tool.Activated)) do
                    local func = connection.Function
                    if func then
                        local funcInfo = debug.getinfo(func)
                        for i = 1, funcInfo.nups do
                            local c, n = debug.getupvalue(func, i)
                            if type(c) == 'number' then
                                if not Orginal[i] then
                                    Orginal[i] = c
                                end
                                debug.setupvalue(func, i, Traced.RapidFire and 0.00000000000000000001 or Orginal[i])
                            end
                        end
                    end
                end
            end
            isOptimizing = false
        end)
    end)
    
    Traced.RapidFire = true
end

local function disableRapidFireGunScript()
    if rapidFireGunScriptConn then rapidFireGunScriptConn:Disconnect() rapidFireGunScriptConn = nil end
    Traced.RapidFire = false
end

addToggleWithNotify(RapidFireGunScriptGroup, 'RapidFireGunScript', {
    Text = 'RapidFireGunScript',
    Default = false,
    Callback = function(v)
        if v then
            enableRapidFireGunScript()
        else
            disableRapidFireGunScript()
        end
    end,
    Tooltip = '>_<'
})

-- === RapidFireM1Spam (Player tab, новая секция) ===
local RapidFireM1Group = Tabs.Player:AddRightGroupbox('>_<')

-- Используем переменные из таблицы G

local function rapidFireM1SafeActivate(tool)
    if not G.rapidFireM1Debounce and tool and tool:IsA('Tool') then
        G.rapidFireM1Debounce = true
        pcall(function() tool:Activate() end)
        task.wait(G.rapidFireM1MinDelay)
        G.rapidFireM1Debounce = false
    end
end

local function rapidFireM1FireLoop()
    while G.rapidFireM1Firing do
        local character = LP.Character
        if character then
            local tool = character:FindFirstChildOfClass('Tool')
            rapidFireM1SafeActivate(tool)
        end
        HRT:Wait()
    end
end

local function rapidFireM1SetupCharacter(character)
    if G.rapidFireM1CharConn then G.rapidFireM1CharConn:Disconnect() end
    G.rapidFireM1CharConn = character.ChildAdded:Connect(function(child)
        if child:IsA('Tool') then
            child.Activated:Connect(function()
                if G.rapidFireM1Firing then
                    rapidFireM1SafeActivate(child)
                end
            end)
        end
    end)
end

local function enableRapidFireM1()
    if G.rapidFireM1ConnBegan then G.rapidFireM1ConnBegan:Disconnect() end
    if G.rapidFireM1ConnEnded then G.rapidFireM1ConnEnded:Disconnect() end
    G.rapidFireM1ConnBegan = S.UIS.InputBegan:Connect(function(input, gp)
        if not gp and input.UserInputType == Enum.UserInputType.MouseButton1 then
            G.rapidFireM1Firing = true
            rapidFireM1FireLoop()
        end
    end)
    G.rapidFireM1ConnEnded = S.UIS.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            G.rapidFireM1Firing = false
        end
    end)
    if LP.Character then rapidFireM1SetupCharacter(LP.Character) end
    LP.CharacterAdded:Connect(function(character)
        character:WaitForChild('Humanoid')
        rapidFireM1SetupCharacter(character)
    end)
end

local function disableRapidFireM1()
    if G.rapidFireM1ConnBegan then G.rapidFireM1ConnBegan:Disconnect() G.rapidFireM1ConnBegan = nil end
    if G.rapidFireM1ConnEnded then G.rapidFireM1ConnEnded:Disconnect() G.rapidFireM1ConnEnded = nil end
    if G.rapidFireM1CharConn then G.rapidFireM1CharConn:Disconnect() G.rapidFireM1CharConn = nil end
    G.rapidFireM1Firing = false
end

addToggleWithNotify(RapidFireM1Group, 'RapidFireM1Spam', {
    Text = 'RapidFireM1',
    Default = false,
    Callback = function(v)
        if v then
            enableRapidFireM1()
        else
            disableRapidFireM1()
        end
    end,
    Tooltip = '>_<'
})

-- === Destroy Cheaters (Misc tab, новая левая секция) ===
local DestroyCheatersGroup = Tabs.Misc:AddLeftGroupbox('>_<')

local destroyCheatersEnabled = false -- разрешение работы функции (toggle)
local destroyCheatersActive = false  -- текущее состояние (keybind)
local destroyCheatersKey = Enum.KeyCode.X
local destroyCheatersLastCFrame = nil
local destroyCheatersHook = nil
local destroyCheatersConn = nil

local function setDestroyCheatersActive(state)
    destroyCheatersActive = state
    getgenv().Finobe1 = state
    if not state and LP.Character and LP.Character:FindFirstChild('HumanoidRootPart') and destroyCheatersLastCFrame then
        LP.Character.HumanoidRootPart.CFrame = destroyCheatersLastCFrame
        Library:Notify('>_< off', 3)
    elseif state then
        destroyCheatersLastCFrame = nil
        Library:Notify('>_< on', 3)
    end
end

if destroyCheatersConn then destroyCheatersConn:Disconnect() end

destroyCheatersConn = HRT:Connect(function()
    if not destroyCheatersEnabled or not destroyCheatersActive then return end
    if LP.Character and LP.Character:FindFirstChild('HumanoidRootPart') then
        local hrp = LP.Character.HumanoidRootPart
        local offset = hrp.CFrame * CFrame.new(9e9, 0/0, M.huge)
        destroyCheatersLastCFrame = hrp.CFrame
        hrp.CFrame = offset
        RND:Wait()
        hrp.CFrame = destroyCheatersLastCFrame
    end
end)

if destroyCheatersHook == nil then
    destroyCheatersHook = hookmetamethod(game, "__index", newcclosure(function(self, key)
        if not checkcaller() then
            if key == "CFrame" and getgenv().Finobe1 and LP.Character and LP.Character:FindFirstChild("HumanoidRootPart") and LP.Character:FindFirstChild("Humanoid") and LP.Character:FindFirstChild("Humanoid").Health > 0 then
                if self == LP.Character.HumanoidRootPart and destroyCheatersLastCFrame ~= nil then
                    return destroyCheatersLastCFrame
                end
            end
        end
        return destroyCheatersHook(self, key)
    end))
end

local destroyCheatersKeyConn
if destroyCheatersKeyConn then destroyCheatersKeyConn:Disconnect() end

destroyCheatersKeyConn = S.UIS.InputBegan:Connect(function(input, gp)
    if not gp and input.KeyCode == destroyCheatersKey and destroyCheatersEnabled then
        setDestroyCheatersActive(not destroyCheatersActive)
    end
end)

addToggleWithNotify(DestroyCheatersGroup, 'DestroyCheaters', {
    Text = 'DestroyCheaters',
    Default = false,
    Callback = function(v)
        destroyCheatersEnabled = v
        if not v and destroyCheatersActive then
            setDestroyCheatersActive(false)
        end
    end,
    Tooltip = '>_<'
}):AddKeyPicker('DestroyCheatersKey', {
    Default = 'X',
    Text = 'DestroyCheatersKey',
    NoUI = false,
    Callback = function(key)
        destroyCheatersKey = Enum.KeyCode[key] or Enum.KeyCode.X
    end
})

DestroyCheatersGroup:AddButton({
    Text = 'DestroyVoid',
    Func = function()
        S.WS.FallenPartsDestroyHeight = 0/0
        Library:Notify('>_<', 3)
    end,
    Tooltip = '>_<'
})

-- === Silent Aim (Combat tab, новая секция) ===
local SilentAimGroup = Tabs.Combat:AddLeftGroupbox('>_<')

getgenv().SilentAim = {
    Options = {
    Enabled = false,
        Mode = "Nuker",
        StickyKey = Enum.KeyCode.Q,
        AutoAir = false, -- Добавлена новая опция AutoAir
        MagicBullet = false, -- Добавлена опция Magic Bullet
        ViewTarget = false, -- Добавлена опция View Target
    },
    Silent = {
        PredictionXZ = 0.12362,
        PredictionY = 0.12362,
        Part = "HumanoidRootPart",
        Offsets = {
            Jump = { Amount = 0 },
            Fall = { Amount = 0 },
        },
    },
    Misc = {
        Checks = {
            WallCheck = false,
            TargetDeathCheck = false,
            KOCheck = false,
            GrabbedCheck = false,
            Resolver = {
                Enabled = false,
                Type = "Calculate CFrame",
            },
        },
    },
    MagicBullet = {
        LastShot = 0,
        Cooldown = 0, -- Без задержки между выстрелами
        Range = 10000, -- Максимальная дистанция для Magic Bullet
        IgnoreKO = false, -- Не стрелять в KO цели по умолчанию
        IgnoreGrabbed = false, -- Не стрелять в схваченные цели по умолчанию
        IgnoreForceField = true, -- Не стрелять в цели с форсфилдом по умолчанию
    },
    currentTarget = nil
}

-- UI для Silent Aim
addToggleWithNotify(SilentAimGroup, 'SilentAimEnabled', {
    Text = 'Ragebot',
    Default = false,
    Callback = function(v) 
        getgenv().SilentAim.Options.Enabled = v 
    end
})
SilentAimGroup:AddDropdown('SilentAimMode', {
    Text = 'Mode',
    Values = {'Sticky', 'Nuker'},
    Default = 'Nuker',
    Callback = function(v) getgenv().SilentAim.Options.Mode = v end
})
addToggleWithNotify(SilentAimGroup, 'SilentAimAutoAir', {
    Text = 'AutoAir',
    Default = false,
    Callback = function(v) 
        getgenv().SilentAim.Options.AutoAir = v 
        
        -- Очищаем соединения при отключении AutoAir
        if not v and getgenv().SilentAim.AutoAirConnections then
            for _, conn in ipairs(getgenv().SilentAim.AutoAirConnections) do
                if conn then conn:Disconnect() end
            end
            getgenv().SilentAim.AutoAirConnections = {}
        end
        
        -- Переинициализируем соединения при включении
        if v and getgenv().SilentAim.Options.Enabled then
            -- Если функция уже загружена, вызываем setupAutoAirConnections
            if getgenv().Loaded_SilentAim then
                -- Устанавливаем небольшую задержку для гарантии корректной инициализации
                task.delay(0.1, function()
                    if getgenv().SilentAim and getgenv().SilentAim.setupAutoAirConnections then
                        getgenv().SilentAim.setupAutoAirConnections()
                    end
                end)
            end
        end
    end,
    Tooltip = '>_<'
})

-- Добавляем Magic Bullet
addToggleWithNotify(SilentAimGroup, 'SilentAimMagicBullet', {
    Text = 'MagicBullet',
    Default = false,
    Callback = function(v) 
        getgenv().SilentAim.Options.MagicBullet = v 
    end,
    Tooltip = '>_<'
})

-- Добавляем View Target
addToggleWithNotify(SilentAimGroup, 'SilentAimViewTarget', {
    Text = 'View',
    Default = false,
    Callback = function(v) 
        getgenv().SilentAim.Options.ViewTarget = v 
        -- Восстанавливаем камеру при выключении
        if not v then
            if LP.Character and LP.Character:FindFirstChildOfClass("Humanoid") then
                game:GetService("Workspace").CurrentCamera.CameraSubject = LP.Character:FindFirstChildOfClass("Humanoid")
            end
        end
    end,
    Tooltip = '>_<'
})

-- Настройки Magic Bullet
local MagicBulletGroup = SilentAimGroup:AddDependencyBox()

MagicBulletGroup:AddSlider('MagicBulletRange', {
    Text = 'Range',
    Default = 10000,
    Min = 100, Max = 10000, Rounding = 0,
    Callback = function(v) 
        getgenv().SilentAim.MagicBullet.Range = tonumber(v) or 10000
    end,
    Tooltip = '>_<'
})

MagicBulletGroup:AddToggle('MagicBulletIgnoreKO', {
    Text = 'IgnoreKO',
    Default = false,
    Callback = function(v) getgenv().SilentAim.MagicBullet.IgnoreKO = v end,
    Tooltip = '>_<'
})

MagicBulletGroup:AddToggle('MagicBulletIgnoreGrabbed', {
    Text = 'IgnoreGrabbed',
    Default = false,
    Callback = function(v) getgenv().SilentAim.MagicBullet.IgnoreGrabbed = v end,
    Tooltip = '>_<'
})

MagicBulletGroup:AddToggle('MagicBulletIgnoreForceField', {
    Text = 'ForceField',
    Default = true,
    Callback = function(v) getgenv().SilentAim.MagicBullet.IgnoreForceField = v end,
    Tooltip = '>_<'
})

MagicBulletGroup:SetupDependencies({{Toggles.SilentAimMagicBullet, true}})
SilentAimGroup:AddInput('SilentAimPredictionXZ', {
    Text = 'PredictionXZ',
    Default = tostring(getgenv().SilentAim.Silent.PredictionXZ),
    Numeric = true,
    Finished = true,
    Callback = function(val) local n = tonumber(val); if n then getgenv().SilentAim.Silent.PredictionXZ = n end end
})
SilentAimGroup:AddInput('SilentAimPredictionY', {
    Text = 'PredictionY',
    Default = tostring(getgenv().SilentAim.Silent.PredictionY),
    Numeric = true,
    Finished = true,
    Callback = function(val) local n = tonumber(val); if n then getgenv().SilentAim.Silent.PredictionY = n end end
})
SilentAimGroup:AddInput('SilentAimJumpOffset', {
    Text = 'JumpOffset',
    Default = tostring(getgenv().SilentAim.Silent.Offsets.Jump.Amount),
    Numeric = true,
    Finished = true,
    Callback = function(val) local n = tonumber(val); if n then getgenv().SilentAim.Silent.Offsets.Jump.Amount = n end end
})
SilentAimGroup:AddInput('SilentAimFallOffset', {
    Text = 'FallOffset',
    Default = tostring(getgenv().SilentAim.Silent.Offsets.Fall.Amount),
    Numeric = true,
    Finished = true,
    Callback = function(val) local n = tonumber(val); if n then getgenv().SilentAim.Silent.Offsets.Fall.Amount = n end end
})
SilentAimGroup:AddLabel('Sticky Key'):AddKeyPicker('SilentAimStickyKey', {
    Default = 'Q',
    Text = 'StickyKey',
    NoUI = false,
    Callback = function(key)
        if typeof(key) == "EnumItem" then
            getgenv().SilentAim.Options.StickyKey = key
        elseif type(key) == "string" then
            getgenv().SilentAim.Options.StickyKey = Enum.KeyCode[key] or Enum.KeyCode.Q
        else
            -- Игнорируем boolean и прочее
        end
    end
})

-- ... существующий UI для Silent Aim ...
SilentAimGroup:AddToggle('SilentAimWallCheck', {
    Text = 'WallCheck',
    Default = false,
    Callback = function(v) getgenv().SilentAim.Misc.Checks.WallCheck = v end
})
SilentAimGroup:AddToggle('SilentAimKOCheck', {
    Text = 'KOCheck',
    Default = false,
    Callback = function(v) getgenv().SilentAim.Misc.Checks.KOCheck = v end
})
SilentAimGroup:AddToggle('SilentAimGrabbedCheck', {
    Text = 'GrabbedCheck',
    Default = false,
    Callback = function(v) getgenv().SilentAim.Misc.Checks.GrabbedCheck = v end
})
SilentAimGroup:AddToggle('SilentAimTargetDeathCheck', {
    Text = 'DeathCheck',
    Default = false,
    Callback = function(v) getgenv().SilentAim.Misc.Checks.TargetDeathCheck = v end
})
SilentAimGroup:AddToggle('SilentAimResolverEnabled', {
    Text = 'Resolver',
    Default = false,
    Callback = function(v) getgenv().SilentAim.Misc.Checks.Resolver.Enabled = v end
})

SilentAimGroup:AddDropdown('SilentAimResolverType', {
    Text = 'ResolverType',
    Values = {'Calculate CFrame', 'Velocity', 'Move direction'},
    Default = getgenv().SilentAim.Misc.Checks.Resolver.Type,
    Callback = function(v) getgenv().SilentAim.Misc.Checks.Resolver.Type = v end
})

SilentAimGroup:AddDropdown('SilentAimPart', {
    Text = 'Hitpart',
    Values = {'HumanoidRootPart', 'UpperTorso', 'LowerTorso', 'Head'},
    Default = getgenv().SilentAim.Silent.Part,
    Callback = function(v) getgenv().SilentAim.Silent.Part = v end
})

-- === Silent Aim Logic ===
if not getgenv().Loaded_SilentAim then
    getgenv().Loaded_SilentAim = true
    local SilentAim = getgenv().SilentAim
    local Players = S.PS
    local Workspace = S.WS
    local UserInputService = S.UIS
    local LocalPlayer = Players.LocalPlayer
    local Camera = Workspace.CurrentCamera
    local Inf = math.huge
    local NewVector2 = Vector2.new
    local NewCFrame = CFrame.new
    local stickyTarget = nil
    local lastPositions, lastUpdateTimes = {}, {}
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local MainEvent = ReplicatedStorage:FindFirstChild("MainEvent")

    local function isPlayerAlive(player)
        return player.Character and player.Character:FindFirstChild("Humanoid") and player.Character.Humanoid.Health > 0
    end
    local function isPlayerGrabbed(player)
        if not player or not player.Character then return false end
        return player.Character:FindFirstChild("GRABBING_CONSTRAINT") ~= nil
    end
    
    local function hasForceField(player)
        if not player or not player.Character then return false end
        return player.Character:FindFirstChildOfClass("ForceField") ~= nil
    end
    local function isPlayerKO(player)
        if not player or not player.Character then return false end
        local bodyEffects = player.Character:FindFirstChild("BodyEffects")
        if bodyEffects then
            local KO = bodyEffects:FindFirstChild("K.O")
            if KO and KO:IsA("BoolValue") and KO.Value then
                return true
            end
        end
        local humanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
        if humanoidRootPart and humanoidRootPart.Anchored then
            return true
        end
        return false
    end
    local function wallCheck(character)
        if not SilentAim.Misc.Checks.WallCheck then return true end
        if not character or not character:FindFirstChild("HumanoidRootPart") then return false end
        
        local targetPos = character.HumanoidRootPart.Position
        local cameraPos = Camera.CFrame.Position
        local distance = (targetPos - cameraPos).Magnitude
        local hitPart = Workspace:FindPartOnRayWithIgnoreList(
            Ray.new(cameraPos, (targetPos - cameraPos).Unit * distance),
            { LocalPlayer.Character, character }
        )
        return hitPart == nil
    end
    local function getClosestPlayer()
        local mousePos = UserInputService:GetMouseLocation()
        local shortestDistance = Inf
        local closestPlayer = nil
        local partName = SilentAim.Silent.Part
        for _, player in ipairs(Players:GetPlayers()) do
            -- Проверяем isPlayerAlive только если TargetDeathCheck включен
            local isAliveCheck = not SilentAim.Misc.Checks.TargetDeathCheck or isPlayerAlive(player)
            
            if player ~= LocalPlayer and isAliveCheck and
               (not SilentAim.Misc.Checks.KOCheck or not isPlayerKO(player)) and
               (not SilentAim.Misc.Checks.GrabbedCheck or not isPlayerGrabbed(player)) and
               wallCheck(player.Character) then
                local character = player.Character
                local part = character and character:FindFirstChild(partName)
                if part then
                    local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
                    local distance = (NewVector2(screenPos.X, screenPos.Y) - mousePos).Magnitude
                    if distance < shortestDistance and onScreen then
                        closestPlayer = player
                        shortestDistance = distance
                    end
                end
            end
        end
        return closestPlayer
    end
    local function predictPosition(player)
        if not player.Character or not player.Character:FindFirstChild(SilentAim.Silent.Part) then return nil end
        local aimPart = player.Character[SilentAim.Silent.Part]
        local aimPartPos = aimPart.Position
        local playerId = player.UserId
        if not lastPositions[playerId] or not lastUpdateTimes[playerId] then
            lastPositions[playerId] = aimPartPos
            lastUpdateTimes[playerId] = tick()
            return aimPartPos
        end
        local currentTime = tick()
        local deltaTime = currentTime - lastUpdateTimes[playerId]
        local predictedPos
        local resolverType = SilentAim.Misc.Checks.Resolver.Type
        if resolverType == "Velocity" then
            local velocity = aimPart.Velocity
            predictedPos = aimPartPos + Vector3.new(
                velocity.X * SilentAim.Silent.PredictionXZ,
                velocity.Y * SilentAim.Silent.PredictionY,
                velocity.Z * SilentAim.Silent.PredictionXZ
            )
        elseif resolverType == "Move direction" then
            predictedPos = aimPartPos + (player.Character.Humanoid.MoveDirection * (SilentAim.Silent.PredictionXZ * 10))
        elseif resolverType == "Calculate CFrame" then
            local distance = (aimPartPos - lastPositions[playerId]).Magnitude
            if distance < 0.001 then
                predictedPos = aimPartPos
            else
                local predictedDistance = (distance / deltaTime) * (0.1 * (SilentAim.Silent.PredictionXZ * 10))
                predictedPos = aimPartPos + (aimPartPos - lastPositions[playerId]).Unit * predictedDistance
                local yChange = (aimPartPos.Y - lastPositions[playerId].Y) / deltaTime * (0.1 * SilentAim.Silent.PredictionY)
                predictedPos = predictedPos + Vector3.new(0, yChange, 0)
            end
        end
        lastPositions[playerId] = aimPartPos
        lastUpdateTimes[playerId] = currentTime
        return predictedPos
    end

    -- Добавляем функции для AutoAir
    local function calculateVelocity(player)
        if not player or not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
            return Vector3.new(0, 0, 0)
        end
        return player.Character.HumanoidRootPart.Velocity
    end

    local function getGun(player)
        if not player or not player.Character then return end
        local tool = player.Character:FindFirstChildOfClass("Tool")
        if not tool then return end
        local info = {}
        for _, obj in pairs(tool:GetDescendants()) do
            if obj and obj.Name then
                local name = STR.lower(obj.Name)
                if name:find("ammo") and not name:find("max") and (obj:IsA("IntValue") or obj:IsA("NumberValue")) then
                    info.ammo = obj
                    info.tool = tool
                    return info
                end
            end
        end
    end

    -- Используем дебаунс из таблицы G для AutoAir

    local function autoAir(target)
        if G.autoAirDebounce or not SilentAim.Options.AutoAir or not target or not target.Character then return end
        
        local targetRootPart = target.Character:FindFirstChild("HumanoidRootPart")
        if not targetRootPart then return end
        
        local humanoid = target.Character:FindFirstChildOfClass("Humanoid")
        if not humanoid then return end
        
        -- Проверяем состояние humanoid или скорость по Y
        local success, isInAir = pcall(function()
            return humanoid:GetState() == Enum.HumanoidStateType.Jumping or 
                   humanoid:GetState() == Enum.HumanoidStateType.Freefall
        end)
        
        if not success then isInAir = false end
        
        local targetVel = calculateVelocity(target)
        local isMovingUp = targetVel.Y > 15
        
        if isInAir or isMovingUp then -- Если цель в воздухе (по состоянию или скорости)
            local character = LocalPlayer.Character
            if not character then return end
            
            local tool = character:FindFirstChildOfClass("Tool")
            if tool then
                G.autoAirDebounce = true
                pcall(function() tool:Activate() end) -- Активировать оружие (выстрел) с защитой
                
                -- Сбрасываем дебаунс через указанное время
                task.delay(G.autoAirDebounceTime, function()
                    G.autoAirDebounce = false
                end)
            end
        end
    end

    -- Настройка соединений для AutoAir (оптимизированная версия)
    local function setupAutoAirConnections()
        -- Используем только один обработчик для текущей цели
        local targetStateConnection = nil
        
        -- Функция для обновления соединения с текущей целью
        local function updateTargetConnection()
            -- Отключаем предыдущее соединение, если оно существует
            if targetStateConnection then 
                targetStateConnection:Disconnect() 
                targetStateConnection = nil
            end
            
            -- Подключаемся только к текущей цели
            if SilentAim.currentTarget and SilentAim.currentTarget.Character then
                local humanoid = SilentAim.currentTarget.Character:FindFirstChildOfClass("Humanoid")
                if humanoid then
                    targetStateConnection = humanoid.StateChanged:Connect(function(_, newState)
                        if SilentAim.Options.AutoAir and 
                          (newState == Enum.HumanoidStateType.Jumping or newState == Enum.HumanoidStateType.Freefall) then
                            autoAir(SilentAim.currentTarget)
                        end
                    end)
                    
                    -- Добавляем соединение в таблицу для последующей очистки
                    SilentAim.AutoAirConnections = SilentAim.AutoAirConnections or {}
                    table.insert(SilentAim.AutoAirConnections, targetStateConnection)
                end
            end
        end
        
        -- Очищаем предыдущие соединения
        if SilentAim.AutoAirConnections then
            for _, conn in ipairs(SilentAim.AutoAirConnections) do
                if conn then conn:Disconnect() end
            end
            SilentAim.AutoAirConnections = {}
        end
        
        -- Обновляем соединение при изменении цели, но с дебаунсом
        local lastTargetUpdateTime = 0
        local targetUpdateDebounce = 0.1 -- 100 мс
        
        local targetChangeConnection = RND:Connect(function()
            if SilentAim.Options.Enabled and SilentAim.Options.AutoAir then
        local now = tick()
                if now - lastTargetUpdateTime > targetUpdateDebounce then
                    lastTargetUpdateTime = now
                    updateTargetConnection()
                end
            end
        end)
        
        -- Очищаем соединения при отключении AutoAir
        SilentAim.AutoAirConnections = SilentAim.AutoAirConnections or {}
        table.insert(SilentAim.AutoAirConnections, targetChangeConnection)
        
        -- Добавляем более редкую проверку вместо проверки каждый кадр
        local checkAutoAirConnection = HRT:Connect(function() -- Используем Heartbeat вместо RenderStepped
            if SilentAim.Options.Enabled and SilentAim.Options.AutoAir and SilentAim.currentTarget then
                local targetChar = SilentAim.currentTarget.Character
                if targetChar then
                    local humanoid = targetChar:FindFirstChildOfClass("Humanoid")
                    if humanoid and (humanoid:GetState() == Enum.HumanoidStateType.Jumping or 
                                    humanoid:GetState() == Enum.HumanoidStateType.Freefall) then
                        autoAir(SilentAim.currentTarget)
                    end
                end
            end
        end)
        
        table.insert(SilentAim.AutoAirConnections, checkAutoAirConnection)
        
        -- Сразу вызываем обновление соединения для текущей цели
        updateTargetConnection()
    end
    
    -- Делаем функцию доступной глобально
    SilentAim.setupAutoAirConnections = setupAutoAirConnections

    RND:Connect(function()
        if not SilentAim.Options.Enabled then
            SilentAim.currentTarget = nil
            return
        end
        local currentTarget = nil
        if SilentAim.Options.Mode == "Sticky" then
            -- Проверяем isPlayerAlive только если TargetDeathCheck включен
            local isAliveCheck = SilentAim.Misc.Checks.TargetDeathCheck and isPlayerAlive(stickyTarget) or stickyTarget ~= nil
            
            if stickyTarget and isAliveCheck and (not SilentAim.Misc.Checks.KOCheck or not isPlayerKO(stickyTarget)) and (not SilentAim.Misc.Checks.GrabbedCheck or not isPlayerGrabbed(stickyTarget)) then
                currentTarget = stickyTarget
            else
                stickyTarget = nil 
            end
        else 
            currentTarget = getClosestPlayer()
        end
        SilentAim.currentTarget = currentTarget
        
        -- Обработка View Target
        pcall(function()
            if SilentAim.Options.ViewTarget and currentTarget and currentTarget.Character then
                local targetHumanoid = currentTarget.Character:FindFirstChildOfClass("Humanoid")
                if targetHumanoid then
                    game:GetService("Workspace").CurrentCamera.CameraSubject = targetHumanoid
                end
            elseif not SilentAim.Options.ViewTarget and LP.Character then
                -- Возвращаем камеру к игроку, если View Target выключен
                local playerHumanoid = LP.Character:FindFirstChildOfClass("Humanoid")
                if playerHumanoid then
                    game:GetService("Workspace").CurrentCamera.CameraSubject = playerHumanoid
                end
            end
        end)
        
            -- Проверка AutoAir для текущей цели - ограничиваем частоту вызовов
    if SilentAim.Options.AutoAir and currentTarget and tick() % 0.2 < 0.02 then
        autoAir(currentTarget)
    end
    
    -- Magic Bullet логика
    if SilentAim.Options.MagicBullet and currentTarget and MainEvent then
        -- Убираем проверку задержки, так как она всегда 0
        local now = tick()
        SilentAim.MagicBullet.LastShot = now
            
        -- Проверяем, что цель валидна
        if currentTarget and currentTarget.Character then
            -- Проверка KO, Grabbed и ForceField с учетом настроек
            local isKO = isPlayerKO(currentTarget)
            local isGrabbed = isPlayerGrabbed(currentTarget)
            local hasFF = hasForceField(currentTarget)
            
            -- Если цель в KO, но мы игнорируем KO, или цель не в KO
            local koCheckPassed = (isKO and SilentAim.MagicBullet.IgnoreKO) or (not isKO)
            -- Если цель схвачена, но мы игнорируем Grabbed, или цель не схвачена
            local grabbedCheckPassed = (isGrabbed and SilentAim.MagicBullet.IgnoreGrabbed) or (not isGrabbed)
            -- Если у цели есть форсфилд и мы проверяем форсфилд, то не стреляем
            local ffCheckPassed = (SilentAim.MagicBullet.IgnoreForceField and not hasFF) or (not SilentAim.MagicBullet.IgnoreForceField)
            
            if koCheckPassed and grabbedCheckPassed and ffCheckPassed then
                local tool = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Tool")
                if tool and tool:FindFirstChild("Handle") then
                    -- Проверяем дистанцию
                    local targetHead = currentTarget.Character:FindFirstChild("Head")
                    local targetHRP = currentTarget.Character:FindFirstChild("HumanoidRootPart")
                    
                    if targetHead and targetHRP then
                        local distance = (LocalPlayer.Character.HumanoidRootPart.Position - targetHRP.Position).Magnitude
                        local range = tonumber(SilentAim.MagicBullet.Range) or 5000
                        
                        if distance <= range then
                            -- Не нужно обновлять время последнего выстрела, так как это сделано выше
                            
                            -- Стреляем в цель через MainEvent (без проверки стен)
                            task.spawn(function()
                                MainEvent:FireServer(
                                    "ShootGun",
                                    tool:FindFirstChild("Handle"),
                                    tool:FindFirstChild("Handle").CFrame.Position,
                                    targetHRP.Position,
                                    targetHead,
                                    Vector3.new(0, 0, -1)
                                )
                            end)
                        end
                    end
                end
            end
                    end
                end
                
    -- Обновляем LastAimbotTarget для Target Strafe
    if getgenv().TS and getgenv().TS.Config and getgenv().TS.Config.Enabled then
        getgenv().TS.Runtime.LastAimbotTarget = currentTarget
    end
    end)
    
    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if not gameProcessed and input.KeyCode == SilentAim.Options.StickyKey and SilentAim.Options.Mode == "Sticky" then
            stickyTarget = getClosestPlayer()
        end
    end)
    local mt = getrawmetatable(game)
    local oldIndex = mt.__index
    setreadonly(mt, false)
    mt.__index = function(self, key)
        if not checkcaller() and self == LocalPlayer:GetMouse() and SilentAim.Options.Enabled then
            if key == "Hit" or key == "Target" then
                local targetPlayer = SilentAim.currentTarget
                if targetPlayer and targetPlayer.Character then
                    local targetPart = targetPlayer.Character:FindFirstChild(SilentAim.Silent.Part)
                    if targetPart then
                        local finalPos = SilentAim.Misc.Checks.Resolver.Enabled and predictPosition(targetPlayer) or
                            (targetPart.Position + (targetPart.Velocity * SilentAim.Silent.PredictionXZ))
                        if finalPos then
                            local humanoid = targetPlayer.Character:FindFirstChildOfClass("Humanoid")
                            if humanoid then
                                if humanoid:GetState() == Enum.HumanoidStateType.Jumping then
                                    finalPos = finalPos + Vector3.new(0, SilentAim.Silent.Offsets.Jump.Amount, 0)
                                elseif humanoid:GetState() == Enum.HumanoidStateType.Freefall then
                                    finalPos = finalPos + Vector3.new(0, SilentAim.Silent.Offsets.Fall.Amount, 0)
                                end
                            end
                            return key == "Hit" and NewCFrame(finalPos) or targetPart
                        end
                    end
                end
            end
        end
        return oldIndex(self, key)
    end
    setreadonly(mt, true)
    local function fixTool(character)
        if character then
            for _, item in ipairs(character:GetChildren()) do
                if item:IsA("Tool") then
                    item.Parent = LocalPlayer:FindFirstChildOfClass("Backpack")
                        break
                    end
                end
        end
    end
    fixTool(LocalPlayer.Character)
    LocalPlayer.CharacterAdded:Connect(fixTool)
    
    -- Инициализация AutoAir соединений
    setupAutoAirConnections()
end

-- ... остальной код ...
-- ... остальной код ...

-- === Crosshair (Visuals tab, right) ===
local CrosshairGroup = Tabs.Visuals:AddRightGroupbox('>_<')

local CrosshairConfig = {
    Enabled = false,
    Color = Color3.fromRGB(255, 255, 255),
    Length = 100,
    Spacing = 5,
    Thickness = 2,
    Rotate = true,
    RotSpeed = 350,
    Outline = false,
    OutlineColor = Color3.fromRGB(0, 0, 0),
    OutlineThickness = 4,
    AttachToTarget = false,
    AttachPart = 'UpperTorso',
    StaticAngle = 0,
}

-- Используем переменные из таблицы G для crosshair

local function destroyCrosshair()
    for _, line in ipairs(G.crosshairLines) do pcall(function() line:Remove() end) end
    for _, line in ipairs(G.crosshairOutlines) do pcall(function() line:Remove() end) end
    G.crosshairLines, G.crosshairOutlines = {}, {}
    if G.crosshairConn then G.crosshairConn:Disconnect() G.crosshairConn = nil end
end

local function createCrosshair()
    destroyCrosshair()
    for i = 1, 4 do
        G.crosshairLines[i] = Drawing.new("Line")
        if CrosshairConfig.Outline then
            G.crosshairOutlines[i] = Drawing.new("Line")
        end
    end
    
    -- Кэшируем математические функции для оптимизации
    local cos, sin, rad = M.cos, M.sin, M.rad
    local lastMousePos = Vector2.new(0, 0)
    local lastTargetPos = Vector2.new(0, 0)
    local lastUpdateTime = 0
    local updateInterval = 1/60 -- Обновление максимум 60 раз в секунду
    
    G.crosshairConn = S.RS.RenderStepped:Connect(function(dt)
        if not CrosshairConfig.Enabled then
            for _, l in ipairs(G.crosshairLines) do l.Visible = false end
            for _, l in ipairs(G.crosshairOutlines) do l.Visible = false end
                return
            end
            
        -- Ограничиваем частоту обновлений
        local now = tick()
        if now - lastUpdateTime < updateInterval then
            return
        end
        lastUpdateTime = now
        
        local mousePos
        if CrosshairConfig.AttachToTarget and getgenv().SilentAim and getgenv().SilentAim.currentTarget then
            local target = getgenv().SilentAim.currentTarget
            if target and target.Character then
                local part = target.Character:FindFirstChild(CrosshairConfig.AttachPart) or target.Character:FindFirstChild('HumanoidRootPart')
                if part then
                    local screenPos, onScreen = S.WS.CurrentCamera:WorldToViewportPoint(part.Position)
                    if onScreen then
                        mousePos = V2.new(screenPos.X, screenPos.Y)
                        -- Проверяем, изменилась ли позиция значительно
                        if (mousePos - lastTargetPos).Magnitude < 1 then
                            mousePos = lastTargetPos -- Используем кэшированную позицию
                        else
                            lastTargetPos = mousePos
                        end
                    end
                end
            end
        end
        
        if not mousePos then
            mousePos = S.UIS:GetMouseLocation()
            -- Проверяем, изменилась ли позиция мыши значительно
            if (mousePos - lastMousePos).Magnitude < 1 then
                mousePos = lastMousePos -- Используем кэшированную позицию
            else
                lastMousePos = mousePos
            end
        end
        
        if CrosshairConfig.Rotate then
            G.crosshairAngle = G.crosshairAngle + CrosshairConfig.RotSpeed * dt
        else
            G.crosshairAngle = CrosshairConfig.StaticAngle
        end
        
        local angle = rad(G.crosshairAngle)
        local cosA, sinA = cos(angle), sin(angle)
        
        local function rot(x, y)
            return V2.new(cosA * x - sinA * y, sinA * x + cosA * y)
        end
        
        local points = {
            {V2.new(0, -CrosshairConfig.Length/2 - CrosshairConfig.Spacing), V2.new(0, -CrosshairConfig.Spacing)},
            {V2.new(0, CrosshairConfig.Spacing), V2.new(0, CrosshairConfig.Length/2 + CrosshairConfig.Spacing)},
            {V2.new(-CrosshairConfig.Length/2 - CrosshairConfig.Spacing, 0), V2.new(-CrosshairConfig.Spacing, 0)},
            {V2.new(CrosshairConfig.Spacing, 0), V2.new(CrosshairConfig.Length/2 + CrosshairConfig.Spacing, 0)}
        }
        
        for i = 1, 4 do
            local startPoint = rot(points[i][1].X, points[i][1].Y)
            local endPoint = rot(points[i][2].X, points[i][2].Y)
            
            if CrosshairConfig.Outline and G.crosshairOutlines[i] then
                local ol = G.crosshairOutlines[i]
                ol.Visible = true
                ol.Thickness = CrosshairConfig.OutlineThickness
                ol.Color = CrosshairConfig.OutlineColor
                ol.From = mousePos + startPoint
                ol.To = mousePos + endPoint
                ol.ZIndex = 0
            elseif G.crosshairOutlines[i] then
                G.crosshairOutlines[i].Visible = false
            end
            
            local l = G.crosshairLines[i]
            l.Visible = true
            l.Thickness = CrosshairConfig.Thickness
            l.Color = CrosshairConfig.Color
            l.From = mousePos + startPoint
            l.To = mousePos + endPoint
            l.ZIndex = 1
        end
    end)
end

addToggleWithNotify(CrosshairGroup, 'CrosshairEnabled', {
    Text = 'Crosshair',
    Default = false,
    Callback = function(v)
        CrosshairConfig.Enabled = v
        if v then createCrosshair() else destroyCrosshair() end
    end
})
:AddColorPicker('CrosshairColor', {
    Default = CrosshairConfig.Color,
    Title = 'Color',
    Callback = function(val) CrosshairConfig.Color = val end
})

CrosshairGroup:AddSlider('CrosshairLength', {
    Text = 'Length',
    Default = CrosshairConfig.Length,
    Min = 10, Max = 300, Rounding = 0,
    Callback = function(val) CrosshairConfig.Length = val end
})
CrosshairGroup:AddSlider('CrosshairSpacing', {
    Text = 'Spacing',
    Default = CrosshairConfig.Spacing,
    Min = 0, Max = 30, Rounding = 0,
    Callback = function(val) CrosshairConfig.Spacing = val end
})
CrosshairGroup:AddSlider('CrosshairThickness', {
    Text = 'Thickness',
    Default = CrosshairConfig.Thickness,
    Min = 1, Max = 10, Rounding = 0,
    Callback = function(val) CrosshairConfig.Thickness = val end
})
CrosshairGroup:AddSlider('CrosshairRotSpeed', {
    Text = 'RotSpeed',
    Default = CrosshairConfig.RotSpeed,
    Min = 0, Max = 1000, Rounding = 0,
    Callback = function(val) CrosshairConfig.RotSpeed = val end
})
addToggleWithNotify(CrosshairGroup, 'CrosshairRotate', {
    Text = 'Spin',
    Default = CrosshairConfig.Rotate,
    Callback = function(v)
        CrosshairConfig.Rotate = v
        if not v then
            G.crosshairAngle = CrosshairConfig.StaticAngle
        end
    end
})
addToggleWithNotify(CrosshairGroup, 'CrosshairOutline', {
    Text = 'Outline',
    Default = CrosshairConfig.Outline,
    Callback = function(v)
        CrosshairConfig.Outline = v
        if CrosshairConfig.Enabled then createCrosshair() end
    end
})
:AddColorPicker('CrosshairOutlineColor', {
    Default = CrosshairConfig.OutlineColor,
    Title = 'Color',
    Callback = function(val) CrosshairConfig.OutlineColor = val end
})
CrosshairGroup:AddSlider('CrosshairOutlineThickness', {
    Text = 'OutlineThick',
    Default = CrosshairConfig.OutlineThickness,
    Min = 1, Max = 20, Rounding = 0,
    Callback = function(val) CrosshairConfig.OutlineThickness = val end
})

addToggleWithNotify(CrosshairGroup, 'CrosshairAttachToTarget', {
    Text = 'AttachTarget',
    Default = false,
    Callback = function(v) CrosshairConfig.AttachToTarget = v end,
    Tooltip = '>_<' 
})
CrosshairGroup:AddDropdown('CrosshairAttachPart', {
    Text = 'Part',
    Values = {'UpperTorso', 'HumanoidRootPart', 'Head', 'LowerTorso'},
    Default = 'UpperTorso',
    Callback = function(val) CrosshairConfig.AttachPart = val end,
    Tooltip = '>_<'
})

CrosshairGroup:AddSlider('CrosshairAngle', {
    Text = 'Angle',
    Default = CrosshairConfig.StaticAngle,
    Min = 0, Max = 360, Rounding = 0,
    Callback = function(val)
        CrosshairConfig.StaticAngle = val
        if not CrosshairConfig.Rotate then
            crosshairAngle = val
        end
    end
})

-- Hotkey for rotate toggle (R)
S.UIS.InputBegan:Connect(function(input, gameProcessed)
    if input.KeyCode == Enum.KeyCode.R and not gameProcessed and CrosshairConfig.Enabled then
        CrosshairConfig.Rotate = not CrosshairConfig.Rotate
    end
end)

-- === HitChams (Combat tab, правая секция) ===
local HitChamsConfig = {
    Enabled = false,
    Material = Enum.Material.Neon,
    Duration = 2,
    Color = Color3.fromRGB(255, 255, 255), -- белый по умолчанию
    Transparency = 0,
}

-- Список частей тела для HitChams
G.HitChamsBodyParts = {
    "Head", "UpperTorso", "LowerTorso",
    "LeftUpperArm", "LeftLowerArm", "LeftHand",
    "RightUpperArm", "RightLowerArm", "RightHand",
    "LeftUpperLeg", "LeftLowerLeg", "LeftFoot",
    "RightUpperLeg", "RightLowerLeg", "RightFoot"
}

-- ВОССТАНОВЛЕНИЕ HitChams
local function HitChams(Player, config)
    config = config or HitChamsConfig
    if not config.Enabled or not Player or not Player.Character or not Player.Character:FindFirstChild("HumanoidRootPart") then return end
    
    Player.Character.Archivable = true
    local Cloned = Player.Character:Clone()
    Cloned.Name = "Player Clone"
    
    -- Удаляем ненужные части
    for _, Part in ipairs(Cloned:GetChildren()) do
        if Part:IsA("BasePart") then
            local keep = false
            for _, validPart in ipairs(G.HitChamsBodyParts) do
                if Part.Name == validPart then keep = true; break end
            end
            if not keep then Part:Destroy() end
        elseif Part:IsA("Accessory") or Part:IsA("Tool") or Part.Name == "face" or Part:IsA("Shirt") or Part:IsA("Pants") or Part:IsA("Hat") then
            Part:Destroy()
        end
    end
    
    -- Удаляем гуманоида
    if Cloned:FindFirstChild("Humanoid") then Cloned.Humanoid:Destroy() end
    
    -- Настраиваем части тела
    for _, Part in ipairs(Cloned:GetChildren()) do
        if Part:IsA("BasePart") then
            Part.CanCollide = false
            Part.Anchored = true
            Part.Transparency = config.Transparency
            Part.Color = config.Color
            Part.Material = config.Material
        end
    end
    
    -- Настраиваем голову отдельно
    if Cloned:FindFirstChild("Head") then
        Cloned.Head.Transparency = config.Transparency
        Cloned.Head.Color = config.Color
        Cloned.Head.Material = config.Material
        if Cloned.Head:FindFirstChild("face") then Cloned.Head.face:Destroy() end
    end
    
    -- Добавляем в мир и настраиваем анимацию
    Cloned.Parent = S.WS
    local tweenInfo = TweenInfo.new(config.Duration, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, 0, true)
    
    -- Анимируем все части
    for _, Part in ipairs(Cloned:GetChildren()) do
        if Part:IsA("BasePart") then S.TS:Create(Part, tweenInfo, {Transparency = 1}):Play() end
    end
    
    -- Удаляем после окончания анимации
    task.delay(config.Duration, function() if Cloned and Cloned.Parent then Cloned:Destroy() end end)
end

-- === HitSounds (инлайн-модуль) ===
local HitSoundsConfig = {
    Enabled = false,
    Sound = "Bameware",
    Volume = 1,
}
local hitsounds = {
    ["RIFK7"]        = "rbxassetid://9102080552",
    ["Bubble"]       = "rbxassetid://6534947588",
    ["Minecraft"]    = "rbxassetid://8837706727",
    ["Cod"]          = "rbxassetid://160432334",
    ["Bameware"]     = "rbxassetid://3124331820",
    ["Neverlose"]    = "rbxassetid://6534948092",
    ["Gamesense"]    = "rbxassetid://4817809188",
    ["Rust"]         = "rbxassetid://1255040462",
    ["Bruh"]         = "rbxassetid://4578740568",
    ["Bell"]         = "rbxassetid://6534947240",
    ["Pick"]         = "rbxassetid://1347140027",
    ["Pop"]          = "rbxassetid://198598793",
    ["Sans"]         = "rbxassetid://3188795283",
    ["Fart"]         = "rbxassetid://130833677",
    ["Big"]          = "rbxassetid://5332005053",
    ["Vine"]         = "rbxassetid://5332680810",
    ["Fatality"]     = "rbxassetid://6534947869",
    ["Bonk"]         = "rbxassetid://5766898159",
    ["Totem"]        = "rbxassetid://135055101757201",
    ["CSHS"]         = "rbxassetid://9065951723"
}
local function PlayHitSound(config)
    config = config or HitSoundsConfig
    if not config.Enabled then return end
    
    local sound = Instance.new("Sound")
    sound.SoundId = hitsounds[config.Sound] or ""
    sound.Volume = config.Volume or 1
    sound.Parent = S.SS
    sound:Play()
    sound.Ended:Connect(function() sound:Destroy() end)
end

local HitChamsGroup = Tabs.Combat:AddRightGroupbox('>_<')
local HitChamsToggle = addToggleWithNotify(HitChamsGroup, 'HitChamsEnabled', {
    Text = 'Chams',
    Default = false,
    Callback = function(v) HitChamsConfig.Enabled = v end,
    Tooltip = '>_<'
})
:AddColorPicker('HitChamsColor', {
    Default = Color3.fromRGB(255,255,255), -- белый по умолчанию
    Title = 'Color',
    Callback = function(val) HitChamsConfig.Color = val end
})

-- Саббокс для HitChams
local HitChamsSub = HitChamsGroup:AddDependencyBox()
HitChamsSub:AddSlider('HitChamsDuration', {
    Text = 'Duration',
    Default = HitChamsConfig.Duration,
    Min = 0.2, Max = 5, Rounding = 2,
    Callback = function(val) HitChamsConfig.Duration = val end
})
HitChamsSub:AddSlider('HitChamsTransparency', {
    Text = 'Transparency',
    Default = HitChamsConfig.Transparency,
    Min = 0, Max = 1, Rounding = 2,
    Callback = function(val) HitChamsConfig.Transparency = val end
})
HitChamsSub:AddDropdown('HitChamsMaterial', {
    Text = 'Material',
    Values = {'Neon', 'ForceField', 'Plastic', 'SmoothPlastic', 'Glass'},
    Default = 'Neon',
    Callback = function(val)
        local mat = Enum.Material[val] or Enum.Material.Neon
        HitChamsConfig.Material = mat
    end
})
HitChamsSub:SetupDependencies({{Toggles.HitChamsEnabled, true}})

-- Тоггл и саббокс для HitSounds
local HitSoundsToggle = addToggleWithNotify(HitChamsGroup, 'HitSoundsEnabled', {
    Text = 'Sounds',
    Default = false,
    Callback = function(v) HitSoundsConfig.Enabled = v end,
    Tooltip = '>_<'
})
local HitSoundsSub = HitChamsGroup:AddDependencyBox()
HitSoundsSub:AddDropdown('HitSoundsSound', {
    Text = 'Sound',
    Values = (function() local t = {}; for k in pairs(hitsounds) do T.insert(t, k) end; T.sort(t); return t end)(),
    Default = HitSoundsConfig.Sound,
    Callback = function(val) HitSoundsConfig.Sound = val end
})
HitSoundsSub:AddSlider('HitSoundsVolume', {
    Text = 'Volume',
    Default = HitSoundsConfig.Volume,
    Min = 0, Max = 3, Rounding = 2,
    Callback = function(val) HitSoundsConfig.Volume = val end
})
HitSoundsSub:SetupDependencies({{Toggles.HitSoundsEnabled, true}})

-- Логика: отслеживание уменьшения HP у цели аимбота
local lastTarget, lastHP
RND:Connect(function()
    if not HitChamsConfig.Enabled and not HitSoundsConfig.Enabled then
        lastTarget, lastHP = nil, nil
        return
    end
    local target = getgenv().SilentAim and getgenv().SilentAim.currentTarget
    if target and target.Character and target.Character:FindFirstChild('Humanoid') then
        local hum = target.Character.Humanoid
        local hp = hum.Health
        if lastTarget ~= target then
            lastTarget = target
            lastHP = hp
        else
            if hp < lastHP then
                if HitChamsConfig.Enabled then
                    HitChams(target, HitChamsConfig)
                end
                if HitSoundsConfig.Enabled then
                    PlayHitSound(HitSoundsConfig)
                end
            end
            lastHP = hp
        end
    else
        lastTarget, lastHP = nil, nil
        end
    end)
    
-- === Combat Tracer (трейсер до цели) ===
local CombatTracerConfig = {
    Enabled = false,
    Color = Color3.fromRGB(255, 255, 255), -- белый по умолчанию
}
local combatTracerLine = nil

addToggleWithNotify(HitChamsGroup, 'CombatTracerEnabled', {
    Text = 'Tracer',
    Default = false,
    Callback = function(v)
        CombatTracerConfig.Enabled = v
        if not v and combatTracerLine then
            combatTracerLine.Visible = false
    end
end
}):AddColorPicker('CombatTracerColor', {
    Default = Color3.fromRGB(255,255,255), -- белый по умолчанию
    Title = 'Color',
    Callback = function(val)
        CombatTracerConfig.Color = val
        if combatTracerLine then
            combatTracerLine.Color = val
        end
    end
})

-- Логика отрисовки трейсеров
-- Используем переменные из таблицы G вместо локальных

HRT:Connect(function() -- Используем Heartbeat вместо RenderStepped
    if not CombatTracerConfig.Enabled then
        if combatTracerLine then
            combatTracerLine.Visible = false
        end
        return
    end
    
    -- Ограничиваем частоту обновлений
    local now = tick()
    if now - G.lastTracerUpdate < G.tracerUpdateInterval then
        return
    end
    G.lastTracerUpdate = now
    
    local target = getgenv().SilentAim and getgenv().SilentAim.currentTarget
    if target and target.Character then
        local torso = target.Character:FindFirstChild('UpperTorso') or target.Character:FindFirstChild('HumanoidRootPart')
        if torso then
            local screenPos, onScreen = S.WS.CurrentCamera:WorldToViewportPoint(torso.Position)
            if onScreen then
                local mousePos = S.UIS:GetMouseLocation()
                if not combatTracerLine then
                    combatTracerLine = Drawing.new('Line')
                    combatTracerLine.Thickness = 2
                    combatTracerLine.Color = CombatTracerConfig.Color
                    combatTracerLine.ZIndex = 10000
                end
                combatTracerLine.From = mousePos
                combatTracerLine.To = Vector2.new(screenPos.X, screenPos.Y)
                combatTracerLine.Color = CombatTracerConfig.Color
                combatTracerLine.Visible = true
            else
                if combatTracerLine then
                    combatTracerLine.Visible = false
                end
            end
        else
            if combatTracerLine then
                combatTracerLine.Visible = false
            end
        end
    else
        if combatTracerLine then
            combatTracerLine.Visible = false
        end
    end
end)

-- 2. Добавить тоггл и дропдаун для HitEffects
local HitEffectsConfig = {
    Enabled = false,
    Type = 'Nova',
    Color = Color3.fromRGB(255,255,255), -- белый по умолчанию
}
local hitEffectsTypes = {'Nova', 'Crescent Slash', 'Coom', 'Cosmic Explosion', 'Slash', 'Atomic Slash'}

-- Настройки для Highlight
local HighlightConfig = {
    Enabled = false,
    OutlineColor = Color3.fromRGB(255, 0, 0), -- красный контур по умолчанию
    FillColor = Color3.fromRGB(255, 0, 0), -- красная заливка
    OutlineTransparency = 0, -- непрозрачный контур
    FillTransparency = 0.5, -- полупрозрачная заливка
    CurrentHighlight = nil
}
local HitEffectsToggle = addToggleWithNotify(HitChamsGroup, 'HitEffectsEnabled', {
    Text = 'HitEffects',
    Default = false,
    Callback = function(v) HitEffectsConfig.Enabled = v end,
    Tooltip = '>_<'
})
:AddColorPicker('HitEffectsColor', {
    Default = Color3.fromRGB(255,255,255), -- белый по умолчанию
    Title = 'Color',
    Callback = function(val) HitEffectsConfig.Color = val end
})
local HitEffectsSub = HitChamsGroup:AddDependencyBox()
HitEffectsSub:AddDropdown('HitEffectsType', {
    Text = 'EffectType',
    Values = hitEffectsTypes,
    Default = HitEffectsConfig.Type,
    Callback = function(val) HitEffectsConfig.Type = val end
})
HitEffectsSub:SetupDependencies({{Toggles.HitEffectsEnabled, true}})

-- Добавляем HitNotifications
local HitNotificationsConfig = {
    Enabled = false,
    Duration = 2,
    ShowDamage = true,
    ShowRemaining = true
}

local HitNotificationsToggle = addToggleWithNotify(HitChamsGroup, 'HitNotificationsEnabled', {
    Text = 'HitNotifications',
    Default = false,
    Callback = function(v) HitNotificationsConfig.Enabled = v end,
    Tooltip = '>_<'
})

local HitNotificationsSub = HitChamsGroup:AddDependencyBox()
HitNotificationsSub:AddSlider('HitNotificationsDuration', {
    Text = 'Duration',
    Default = HitNotificationsConfig.Duration,
    Min = 1, Max = 5, Rounding = 0,
    Callback = function(val) HitNotificationsConfig.Duration = val end
})
HitNotificationsSub:AddToggle('HitNotificationsShowDamage', {
    Text = 'Show Damage',
    Default = HitNotificationsConfig.ShowDamage,
    Callback = function(v) HitNotificationsConfig.ShowDamage = v end
})
HitNotificationsSub:AddToggle('HitNotificationsShowRemaining', {
    Text = 'Show HP',
    Default = HitNotificationsConfig.ShowRemaining,
    Callback = function(v) HitNotificationsConfig.ShowRemaining = v end
})
HitNotificationsSub:SetupDependencies({{Toggles.HitNotificationsEnabled, true}})

-- Добавляем Highlight
local HighlightToggle = addToggleWithNotify(HitChamsGroup, 'HighlightEnabled', {
    Text = 'Highlight',
    Default = false,
    Callback = function(v) 
        HighlightConfig.Enabled = v 
        
        -- Удаляем существующий хайлайт при выключении
        if not v and HighlightConfig.CurrentHighlight then
            pcall(function()
                HighlightConfig.CurrentHighlight:Destroy()
                HighlightConfig.CurrentHighlight = nil
            end)
        end
    end,
    Tooltip = '>_<'
})

local HighlightSub = HitChamsGroup:AddDependencyBox()

-- Добавляем колорпикеры для цветов контура и заливки
HighlightSub:AddLabel('Outline Color'):AddColorPicker('HighlightOutlineColor', {
    Default = HighlightConfig.OutlineColor,
    Title = 'Outline',
    Callback = function(val) 
        HighlightConfig.OutlineColor = val 
        -- Обновляем цвет, если хайлайт активен
        if HighlightConfig.CurrentHighlight then
            HighlightConfig.CurrentHighlight.OutlineColor = val
        end
    end
})

HighlightSub:AddLabel('Fill Color'):AddColorPicker('HighlightFillColor', {
    Default = HighlightConfig.FillColor,
    Title = 'Fill',
    Callback = function(val) 
        HighlightConfig.FillColor = val 
        -- Обновляем цвет, если хайлайт активен
        if HighlightConfig.CurrentHighlight then
            HighlightConfig.CurrentHighlight.FillColor = val
        end
    end
})

-- Добавляем слайдеры для прозрачности
HighlightSub:AddSlider('HighlightOutlineTransparency', {
    Text = 'Outline Transparency',
    Default = HighlightConfig.OutlineTransparency,
    Min = 0, Max = 1, Rounding = 2,
    Callback = function(val) 
        HighlightConfig.OutlineTransparency = val 
        -- Обновляем прозрачность, если хайлайт активен
        if HighlightConfig.CurrentHighlight then
            HighlightConfig.CurrentHighlight.OutlineTransparency = val
        end
    end
})

HighlightSub:AddSlider('HighlightFillTransparency', {
    Text = 'Fill Transparency',
    Default = HighlightConfig.FillTransparency,
    Min = 0, Max = 1, Rounding = 2,
    Callback = function(val) 
        HighlightConfig.FillTransparency = val 
        -- Обновляем прозрачность, если хайлайт активен
        if HighlightConfig.CurrentHighlight then
            HighlightConfig.CurrentHighlight.FillTransparency = val
        end
    end
})

HighlightSub:SetupDependencies({{Toggles.HighlightEnabled, true}})

-- 3. Загрузка библиотеки эффектов (один раз)
G.HitEffectsLib = nil
G.hitEffectsLoading = false
local function getHitEffectsLib()
    if G.HitEffectsLib then return G.HitEffectsLib end
    if G.hitEffectsLoading then return nil end
    
    G.hitEffectsLoading = true
    task.spawn(function()
        pcall(function()
            G.HitEffectsLib = loadstring(game:HttpGet('https://raw.githubusercontent.com/ZXCdswqezxc/halalware/refs/heads/main/effects'))()
        end)
        G.hitEffectsLoading = false
    end)
    
    return nil
end

-- 4. Вызов эффекта при уроне цели (в том же месте, где HitChams/HitSounds)
local lastTarget, lastHP = nil, nil
-- Используем G.lastDamageTick вместо локальной переменной

-- Функция для управления хайлайтом цели
G.updateHighlight = function(target)
    -- Если хайлайт выключен, удаляем существующий и выходим
    if not HighlightConfig.Enabled then
        if HighlightConfig.CurrentHighlight then
            pcall(function()
                HighlightConfig.CurrentHighlight:Destroy()
                HighlightConfig.CurrentHighlight = nil
            end)
        end
        return
    end
    
    -- Если нет цели или её персонажа, удаляем хайлайт
    if not target or not target.Character then
        if HighlightConfig.CurrentHighlight then
            pcall(function()
                HighlightConfig.CurrentHighlight:Destroy()
                HighlightConfig.CurrentHighlight = nil
            end)
        end
        return
    end
    
    -- Если хайлайт уже существует, проверяем, нужно ли его переместить на новую цель
    if HighlightConfig.CurrentHighlight then
        if HighlightConfig.CurrentHighlight.Parent ~= target.Character then
            -- Если цель изменилась, удаляем старый хайлайт
            pcall(function()
                HighlightConfig.CurrentHighlight:Destroy()
                HighlightConfig.CurrentHighlight = nil
            end)
        end
    end
    
    -- Если хайлайта нет, создаем новый
    if not HighlightConfig.CurrentHighlight then
        pcall(function()
            local highlight = Instance.new("Highlight")
            highlight.OutlineColor = HighlightConfig.OutlineColor
            highlight.FillColor = HighlightConfig.FillColor
            highlight.OutlineTransparency = HighlightConfig.OutlineTransparency
            highlight.FillTransparency = HighlightConfig.FillTransparency
            highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
            highlight.Parent = target.Character
            
            HighlightConfig.CurrentHighlight = highlight
        end)
    end
end

-- Объединяем все эффекты в одну функцию для оптимизации
G.processHitEffects = function(target)
    if not target or not target.Character or not target.Character:FindFirstChild('Humanoid') then return end
    
    -- Обновляем время последнего урона (без проверки дебаунса)
    G.lastDamageTick = tick()
    
    -- Применяем эффекты
    if HitChamsConfig.Enabled then HitChams(target, HitChamsConfig) end
    if HitSoundsConfig.Enabled then PlayHitSound(HitSoundsConfig) end
    
    if HitEffectsConfig.Enabled then
        task.spawn(function()
            local lib = getHitEffectsLib()
            if lib and lib.Functions and lib.Functions.Effect then
                lib.Functions.Effect(target.Character, HitEffectsConfig.Type, HitEffectsConfig.Color)
            end
        end)
    end
    
    -- Показываем уведомление о нанесенном уроне
    if HitNotificationsConfig.Enabled and target.Character:FindFirstChild('Humanoid') then
        local hum = target.Character.Humanoid
        local notifText = ">_<"
        
        Library:Notify('>_<', HitNotificationsConfig.Duration)
    end
end

-- Используем Heartbeat вместо RenderStepped для снижения нагрузки
HRT:Connect(function()
    local target = getgenv().SilentAim and getgenv().SilentAim.currentTarget
    
    -- Обновляем хайлайт для текущей цели аимбота
    if HighlightConfig.Enabled then
        G.updateHighlight(target)
    end
    
    -- Если никакие эффекты при попадании не включены, выходим
    if not HitChamsConfig.Enabled and not HitSoundsConfig.Enabled and not HitEffectsConfig.Enabled and not HitNotificationsConfig.Enabled then
        lastTarget, lastHP = nil, nil
        return
    end
    
    if target and target.Character and target.Character:FindFirstChild('Humanoid') then
        local hum = target.Character.Humanoid
        local hp = hum.Health
        
        if lastTarget ~= target then
            lastTarget = target
            lastHP = hp
        else if hp < lastHP then
                G.processHitEffects(target)
            end
            lastHP = hp
        end
    else
        lastTarget, lastHP = nil, nil
    end
end)

-- Поиск корневой части персонажа (оставляем, может пригодиться для других функций)
G.findRootPart = function(character)
    return character:FindFirstChild("HumanoidRootPart") or
           character:FindFirstChild("Torso") or
           character:FindFirstChild("UpperTorso") or
           character:FindFirstChild("LowerTorso")
end

-- === Target Strafe (Combat tab, новая секция) ===
local TargetStrafeGroup = Tabs.Combat:AddLeftGroupbox('>_<')

-- Объединяем все переменные в одну таблицу
local TS = {
    Config = {
        Enabled = false,
        Radius = 10,
        Height = 5,
        Speed = 2,
        Visualise = false,
        VisualiseColor = Color3.fromRGB(255, 255, 255),
        UseDesync = false -- Новая опция для переключения между режимами
    },
    Runtime = {
        Angle = 0,
        Connection = nil,
        Target = nil,
        FollowPart = nil,
        DesyncPosition = nil,
        VisualiseDrawing = nil,
        LastAimbotTarget = nil
    }
}

-- Делаем TS доступным глобально
getgenv().TS = TS

-- Функция для создания FollowPart для камеры
TS.createFollowPart = function()
    if TS.Runtime.FollowPart and TS.Runtime.FollowPart.Parent then
        TS.Runtime.FollowPart:Destroy()
    end
    
    local part = Instance.new("Part")
    part.Name = "TargetStrafeFollowPart"
    part.Anchored = true
    part.CanCollide = false
    part.Transparency = 1
    part.Size = Vector3.new(0.1, 0.1, 0.1)
    part.Parent = game:GetService("Workspace")

    -- Инициализируем начальную позицию
    if LP.Character and LP.Character:FindFirstChild("HumanoidRootPart") then
        part.CFrame = LP.Character.HumanoidRootPart.CFrame + Vector3.new(0, 2.0, 0)
    end
    
    return part
end

-- Функция восстановления камеры
TS.resetCamera = function()
    if TS.Runtime.FollowPart and TS.Runtime.FollowPart.Parent then
        TS.Runtime.FollowPart:Destroy()
        TS.Runtime.FollowPart = nil
    end
    
    if LP.Character and LP.Character:FindFirstChildOfClass("Humanoid") then
        game:GetService("Workspace").CurrentCamera.CameraSubject = LP.Character:FindFirstChildOfClass("Humanoid")
    end
end

-- Функция для визуализации десинка
TS.updateVisual = function()
    -- Если визуализация отключена, удаляем трейсер
    if not TS.Config.Visualise or not TS.Runtime.DesyncPosition then
        if TS.Runtime.VisualiseDrawing then 
            TS.Runtime.VisualiseDrawing.Visible = false 
        end
        return
    end
    
    -- Создаем трейсер, если его еще нет
    if not TS.Runtime.VisualiseDrawing then
        TS.Runtime.VisualiseDrawing = Drawing.new("Line")
        TS.Runtime.VisualiseDrawing.Thickness = 2
        TS.Runtime.VisualiseDrawing.ZIndex = 10000
    end
    
    -- Получаем позицию десинка на экране
    local screenPos, onScreen = game:GetService("Workspace").CurrentCamera:WorldToViewportPoint(TS.Runtime.DesyncPosition)
    
    if onScreen then
        TS.Runtime.VisualiseDrawing.From = game:GetService("UserInputService"):GetMouseLocation()
        TS.Runtime.VisualiseDrawing.To = Vector2.new(screenPos.X, screenPos.Y)
        TS.Runtime.VisualiseDrawing.Color = TS.Config.VisualiseColor
        TS.Runtime.VisualiseDrawing.Visible = true
    else
        TS.Runtime.VisualiseDrawing.Visible = false
    end
end

-- Функция для полного удаления визуализации
TS.cleanupVisual = function()
    if TS.Runtime.VisualiseDrawing then
        TS.Runtime.VisualiseDrawing:Remove()
        TS.Runtime.VisualiseDrawing = nil
    end
end

-- Основная функция стрейфа с десинком
local function performTargetStrafeDesync()
    if not TS.Config.Enabled or not TS.Config.UseDesync then 
        TS.Runtime.DesyncPosition = nil
        
        -- Убедимся, что визуализация скрыта при отключении
        if TS.Runtime.VisualiseDrawing and TS.Runtime.VisualiseDrawing.Visible then
            TS.Runtime.VisualiseDrawing.Visible = false
        end
        
        return 
    end
    
    -- Получаем цель только из аимбота
    local target = getgenv().SilentAim and getgenv().SilentAim.currentTarget
    
    -- Если нет цели, выходим
    if not target or not target.Character then 
        TS.Runtime.DesyncPosition = nil
        return 
    end
    
    local targetHRP = target.Character:FindFirstChild("HumanoidRootPart")
    if not targetHRP then 
        TS.Runtime.DesyncPosition = nil
        return 
    end
    
    local character = LP.Character
    if not character then 
        TS.Runtime.DesyncPosition = nil
        return 
    end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then 
        TS.Runtime.DesyncPosition = nil
        return 
    end
    
    -- Обновляем угол
    TS.Runtime.Angle = TS.Runtime.Angle + TS.Config.Speed * HRT:Wait()
    
    -- Вычисляем смещение
    local offset = Vector3.new(
        math.cos(TS.Runtime.Angle) * TS.Config.Radius,
        TS.Config.Height,
        math.sin(TS.Runtime.Angle) * TS.Config.Radius
    )
    
    -- Сохраняем оригинальный CFrame
    local originalCFrame = hrp.CFrame
    
    -- Новая позиция вокруг цели
    local targetPos = targetHRP.Position
    local newPos = targetPos + offset
    local newCFrame = CFrame.new(newPos, targetPos) -- Смотрим на цель
    
    -- Сохраняем позицию десинка для визуализации
    TS.Runtime.DesyncPosition = newPos
    
    -- Обновляем визуализацию
    if TS.Config.Visualise then
        TS.updateVisual()
    end
    
    -- Обновляем позицию FollowPart для фиксации камеры
    if TS.Config.Enabled and TS.Config.UseDesync then  -- Проверяем, что Target Strafe всё ещё активен
        if TS.Runtime.FollowPart and TS.Runtime.FollowPart.Parent then
            TS.Runtime.FollowPart.CFrame = originalCFrame + Vector3.new(0, 2.0, 0) -- Увеличил высоту с 1.5 до 2.0
        else
            TS.Runtime.FollowPart = TS.createFollowPart()
            TS.Runtime.FollowPart.CFrame = originalCFrame + Vector3.new(0, 2.0, 0)
        end
        game:GetService("Workspace").CurrentCamera.CameraSubject = TS.Runtime.FollowPart
    end
    
    -- Устанавливаем новую позицию
    hrp.CFrame = newCFrame
    
    -- Возвращаем оригинальную позицию после отрисовки кадра
    task.spawn(function()
        game:GetService("RunService").RenderStepped:Wait() -- Ждем один кадр отрисовки в отдельном потоке
        if hrp and hrp.Parent then -- Проверяем, что HRP все еще существует
            hrp.CFrame = originalCFrame
        end
    end)
    
    -- Возвращаем камеру к игроку после десинка
    task.spawn(function()
        game:GetService("RunService").RenderStepped:Wait() -- Используем RenderStepped для синхронизации с отрисовкой
        if character and character:FindFirstChildOfClass("Humanoid") then
            game:GetService("Workspace").CurrentCamera.CameraSubject = character:FindFirstChildOfClass("Humanoid")
        end
    end)
end

-- Основная функция стрейфа (без десинка)
local function performTargetStrafe()
    if not TS.Config.Enabled then return end
    if TS.Config.UseDesync then return end
    
    local target = getgenv().SilentAim and getgenv().SilentAim.currentTarget
    
    if not target or not target.Character then return end
    
    local targetHRP = target.Character:FindFirstChild("HumanoidRootPart")
    if not targetHRP then return end
    
    local character = LP.Character
    if not character then return end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    
    -- Обновляем угол
    TS.Runtime.Angle = TS.Runtime.Angle + TS.Config.Speed * HRT:Wait()
    
    -- Вычисляем смещение
    local offset = Vector3.new(
        math.cos(TS.Runtime.Angle) * TS.Config.Radius,
        TS.Config.Height,
        math.sin(TS.Runtime.Angle) * TS.Config.Radius
    )
    
    -- Новая позиция вокруг цели
    local targetPos = targetHRP.Position
    local newPos = targetPos + offset
    
    -- Плавно перемещаемся к новой позиции
    hrp.CFrame = CFrame.new(hrp.Position:Lerp(newPos, 0.1), targetPos)
end

-- Функция включения стрейфа
local function toggleTargetStrafe(state)
    TS.Config.Enabled = state
    
    -- Отключаем предыдущие соединения
    if TS.Runtime.Connection then
        TS.Runtime.Connection:Disconnect()
        TS.Runtime.Connection = nil
    end
    
    -- Очищаем визуализацию при отключении
    if not state then
        TS.Runtime.DesyncPosition = nil
        TS.cleanupVisual()
        TS.resetCamera()
    end
    
    if state then
        -- Создаем FollowPart для камеры если нужен десинк
        if TS.Config.UseDesync then
            TS.Runtime.FollowPart = TS.createFollowPart()
        end
        
        -- Запускаем стрейф с правильной функцией в зависимости от режима
        if TS.Config.UseDesync then
            TS.Runtime.Connection = HRT:Connect(performTargetStrafeDesync)
        else
            TS.Runtime.Connection = HRT:Connect(performTargetStrafe)
        end
        Library:Notify('>_< on', 3)
    else
        -- Отключаем камеру
        TS.resetCamera()
        Library:Notify('>_< off', 3)
    end
end

-- UI для Target Strafe
addToggleWithNotify(TargetStrafeGroup, 'TargetStrafeEnabled', {
    Text = 'TargetStrafe',
    Default = false,
    Callback = function(v) toggleTargetStrafe(v) end,
    Tooltip = '>_<'
})

addToggleWithNotify(TargetStrafeGroup, 'TargetStrafeDesync', {
    Text = 'UseDesync',
    Default = false,
    Callback = function(v)
        TS.Config.UseDesync = v
        if TS.Config.Enabled then
            toggleTargetStrafe(false)
            toggleTargetStrafe(true)
        end
    end,
    Tooltip = '>_<'
})

TargetStrafeGroup:AddSlider('TargetStrafeRadius', {
    Text = 'Radius',
    Default = TS.Config.Radius,
    Min = 1, Max = 20, Rounding = 1,
    Callback = function(v) TS.Config.Radius = v end
})

TargetStrafeGroup:AddSlider('TargetStrafeHeight', {
    Text = 'Height',
    Default = TS.Config.Height,
    Min = -50, Max = 50, Rounding = 1,
    Callback = function(val) TS.Config.Height = val end
})

TargetStrafeGroup:AddSlider('TargetStrafeSpeed', {
    Text = 'Speed',
    Default = TS.Config.Speed,
    Min = 0.5, Max = 30, Rounding = 1,
    Callback = function(val) TS.Config.Speed = val end
})

addToggleWithNotify(TargetStrafeGroup, 'TargetStrafeVisualise', {
    Text = 'Visualise',
    Default = false,
    Callback = function(v) 
        TS.Config.Visualise = v
        
        -- Если отключаем визуализацию, удаляем трейсер
        if not v then
            TS.cleanupVisual()
        end
    end,
    Tooltip = '>_<'
}):AddColorPicker('TargetStrafeVisualiseColor', {
    Default = Color3.fromRGB(255, 255, 255),
    Title = 'Color',
    Callback = function(val)
        TS.Config.VisualiseColor = val
        
        -- Обновляем цвет существующего трейсера, если он активен
        if TS.Runtime.VisualiseDrawing and TS.Runtime.VisualiseDrawing.Visible then
            TS.Runtime.VisualiseDrawing.Color = val
        end
    end
})

-- Обработка смены персонажа
LP.CharacterAdded:Connect(function(newCharacter)
    if TS.Config.Enabled then
        -- Пересоздаем камеру при смене персонажа
        task.wait(0.5) -- Ждем загрузки персонажа
        if TS.Runtime.FollowPart and TS.Config.UseDesync then
            TS.resetCamera()
            TS.Runtime.FollowPart = TS.createFollowPart()
        end
    end
end)

-- Следим за изменениями цели аимбота и обновляем визуализацию
local aimbotTargetWatcher = nil
aimbotTargetWatcher = HRT:Connect(function()
    -- Обновляем визуализацию десинка на каждом кадре
    if TS.Config.Enabled and TS.Config.UseDesync and TS.Config.Visualise and TS.Runtime.DesyncPosition then
        TS.updateVisual()
    else
        if TS.Runtime.VisualiseDrawing and TS.Runtime.VisualiseDrawing.Visible then
            TS.Runtime.VisualiseDrawing.Visible = false
        end
    end
end)

-- === Camera Unlock (Player tab) ===
local CameraGroup = Tabs.Player:AddRightGroupbox('>_<')

addToggleWithNotify(CameraGroup, 'UnlockCameraDistance', {
    Text = 'Unlock Camera',
    Default = false,
    Callback = function(v) 
        if v then
            game.Players.LocalPlayer.CameraMaxZoomDistance = math.huge
        else
            game.Players.LocalPlayer.CameraMaxZoomDistance = 128 -- Стандартное значение
        end
    end,
    Tooltip = '>_<'
})

-- === AutoStomp (Combat tab, new section) ===
local AutoStompGroup = Tabs.Combat:AddRightGroupbox('>_<')

-- Настройки AutoStomp
getgenv().AutoStomp = {
    Enabled = false,
    StompCount = 100,
    StompInterval = 0.099,
    YOffset = 2,
    isActive = false,
    stompCounter = 0,
    lastStompTime = nil,
    followPart = nil
}

-- UI для AutoStomp
addToggleWithNotify(AutoStompGroup, 'AutoStompEnabled', {
    Text = 'AutoStomp',
    Default = false,
    Callback = function(v) 
        getgenv().AutoStomp.Enabled = v 
        if not v and getgenv().AutoStomp.isActive then
            -- Очистка при отключении
            getgenv().AutoStomp.isActive = false
            getgenv().AutoStomp.stompCounter = 0
            getgenv().AutoStomp.lastStompTime = nil
            resetAutoStompCamera()
        end
    end,
    Tooltip = '>_<'
})

AutoStompGroup:AddSlider('AutoStompInterval', {
    Text = 'Stomp Interval',
    Default = getgenv().AutoStomp.StompInterval,
    Min = 0.01, Max = 1, Rounding = 3,
    Callback = function(v) getgenv().AutoStomp.StompInterval = v end,
    Tooltip = '>_<'
})

-- Функции AutoStomp
local function isPlayerKO(player)
    if not player or not player.Character then return false end
    
    local bodyEffects = player.Character:FindFirstChild("BodyEffects")
    if not bodyEffects then return false end
    
    local ko = bodyEffects:FindFirstChild("K.O")
    local grabbed = bodyEffects:FindFirstChild("Grabbed")
    
    -- Проверяем, что игрок в нокауте и не схвачен
    return ko and ko.Value and (not grabbed or not grabbed.Value)
end

local function getRagdollPart(character)
    if not character then return nil end
    
    -- Приоритет частей тела для стомпа
    for _, partName in ipairs({"UpperTorso", "LowerTorso"}) do
        local part = character:FindFirstChild(partName)
        if part then return part end
    end
    
    return nil
end

-- Создаем FollowPart для камеры
local function createAutoStompFollowPart()
    if getgenv().AutoStomp.followPart and getgenv().AutoStomp.followPart.Parent then
        getgenv().AutoStomp.followPart:Destroy()
    end
    
    local part = Instance.new("Part")
    part.Name = "AutoStompFollowPart"
    part.Anchored = true
    part.CanCollide = false
    part.Transparency = 1
    part.Size = V3.new(0.1, 0.1, 0.1)
    part.Parent = S.WS
    
    return part
end

-- Восстановление камеры
local function resetAutoStompCamera()
    if getgenv().AutoStomp.followPart and getgenv().AutoStomp.followPart.Parent then
        getgenv().AutoStomp.followPart:Destroy()
        getgenv().AutoStomp.followPart = nil
    end
    
    -- Проверяем, не активен ли Target Strafe
    local isTargetStrafeActive = getgenv().TS and getgenv().TS.Config and getgenv().TS.Config.Enabled
    
    -- Восстанавливаем камеру только если Target Strafe не активен
    if not isTargetStrafeActive then
        if LP.Character and LP.Character:FindFirstChildOfClass("Humanoid") then
            S.WS.CurrentCamera.CameraSubject = LP.Character:FindFirstChildOfClass("Humanoid")
        end
    end
end

local function performStomp()
    game:GetService("ReplicatedStorage").MainEvent:FireServer("Stomp")
    
    -- Для некоторых игр может потребоваться дополнительный вызов
    local assets = game:GetService("ReplicatedStorage"):FindFirstChild("assets")
    if assets and assets:FindFirstChild("dh") then
        assets.dh.MainEvent:FireServer("Stomp")
    end
    
    getgenv().AutoStomp.stompCounter = getgenv().AutoStomp.stompCounter - 1
    getgenv().AutoStomp.lastStompTime = tick()
    
    if getgenv().AutoStomp.stompCounter <= 0 then
        getgenv().AutoStomp.isActive = false
        resetAutoStompCamera()
    end
end

-- Основная функция AutoStomp
G.applyAutoStomp = function()
    if not getgenv().AutoStomp.Enabled then
        if getgenv().AutoStomp.isActive then
            getgenv().AutoStomp.isActive = false
            getgenv().AutoStomp.stompCounter = 0
            getgenv().AutoStomp.lastStompTime = nil
            resetAutoStompCamera()
        end
        return
    end
    
    local targetPlayer = getgenv().SilentAim and getgenv().SilentAim.currentTarget
    if not targetPlayer or not targetPlayer.Character then return end
    
    -- Проверяем, находится ли игрок в нокауте и не схвачен
    if not isPlayerKO(targetPlayer) then 
        if getgenv().AutoStomp.isActive then
            getgenv().AutoStomp.isActive = false
            resetAutoStompCamera()
        end
        return 
    end
    
    -- Получаем часть тела для телепорта
    local ragdollPart = getRagdollPart(targetPlayer.Character)
    if not ragdollPart then return end
    
    -- Инициализируем стомп, если ещё не активен
    if not getgenv().AutoStomp.isActive then
        getgenv().AutoStomp.isActive = true
        getgenv().AutoStomp.stompCounter = getgenv().AutoStomp.StompCount
        getgenv().AutoStomp.lastStompTime = tick()
        getgenv().AutoStomp.followPart = createAutoStompFollowPart()
    end
    
    if getgenv().AutoStomp.isActive then
        -- Сохраняем оригинальную позицию
        local hrp = LP.Character and LP.Character:FindFirstChild("HumanoidRootPart")
        if not hrp then return end
        
        local originalCFrame = hrp.CFrame
        local targetPosition = ragdollPart.Position
        
        -- Обновляем позицию FollowPart для фиксации камеры
        -- Проверяем, не активен ли Target Strafe
        local isTargetStrafeActive = getgenv().TS and getgenv().TS.Config and getgenv().TS.Config.Enabled
        
        if getgenv().AutoStomp.followPart and not isTargetStrafeActive then
            getgenv().AutoStomp.followPart.CFrame = originalCFrame + V3.new(0, 2.0, 0)
            Cam.CameraSubject = getgenv().AutoStomp.followPart
        end
        
        -- Телепортируемся к цели для стомпа
        hrp.CFrame = CFrame.new(targetPosition + Vector3.new(0, getgenv().AutoStomp.YOffset, 0))
        S.RS.RenderStepped:Wait()
        hrp.CFrame = originalCFrame
        
        -- Возвращаем камеру к игроку после десинка только если Target Strafe не активен
        task.spawn(function()
            S.RS.RenderStepped:Wait() -- Используем RenderStepped для синхронизации с отрисовкой
            
            -- Проверяем, не активен ли Target Strafe
            local isTargetStrafeActive = getgenv().TS and getgenv().TS.Config and getgenv().TS.Config.Enabled
            
            -- Возвращаем камеру только если Target Strafe не активен
            if not isTargetStrafeActive then
                if LP.Character and LP.Character:FindFirstChildOfClass("Humanoid") then
                    Cam.CameraSubject = LP.Character:FindFirstChildOfClass("Humanoid")
                end
            end
        end)
        
        -- Выполняем стомп с заданным интервалом
        if getgenv().AutoStomp.lastStompTime and 
           (tick() - getgenv().AutoStomp.lastStompTime) >= getgenv().AutoStomp.StompInterval and 
           getgenv().AutoStomp.stompCounter > 0 then
            performStomp()
        end
    end
end

-- Добавляем AutoStomp в основной цикл
HRT:Connect(function()
    if getgenv().AutoStomp.Enabled then
        G.applyAutoStomp()
    end
end)

-- === Grip (Combat tab, new section) ===
local GripGroup = Tabs.Combat:AddRightGroupbox('>_<')

-- Create UI components
addToggleWithNotify(GripGroup, 'GripEnabled', {
    Text = 'CustomGrip',
    Default = false,
    Callback = function(v) G.GripSettings.Enabled = v end,
    Tooltip = '>_<'
})

-- Position sliders
GripGroup:AddLabel('Position:')
GripGroup:AddSlider('GripPosX', {
    Text = 'X',
    Default = 0,
    Min = -100, Max = 100, Rounding = 1,
    Callback = function(val) G.GripSettings.Position = Vector3.new(val, G.GripSettings.Position.Y, G.GripSettings.Position.Z) end
})

GripGroup:AddSlider('GripPosY', {
    Text = 'Y',
    Default = 0,
    Min = -100, Max = 100, Rounding = 1,
    Callback = function(val) G.GripSettings.Position = Vector3.new(G.GripSettings.Position.X, val, G.GripSettings.Position.Z) end
})

GripGroup:AddSlider('GripPosZ', {
    Text = 'Z',
    Default = 0,
    Min = -100, Max = 100, Rounding = 1,
    Callback = function(val) G.GripSettings.Position = Vector3.new(G.GripSettings.Position.X, G.GripSettings.Position.Y, val) end
})

-- Rotation sliders
GripGroup:AddLabel('Rotation:')
GripGroup:AddSlider('GripRotX', {
    Text = 'X',
    Default = 0,
    Min = -180, Max = 180, Rounding = 1,
    Callback = function(val) G.GripSettings.Rotation = Vector3.new(val, G.GripSettings.Rotation.Y, G.GripSettings.Rotation.Z) end
})

GripGroup:AddSlider('GripRotY', {
    Text = 'Y',
    Default = 0,
    Min = -180, Max = 180, Rounding = 1,
    Callback = function(val) G.GripSettings.Rotation = Vector3.new(G.GripSettings.Rotation.X, val, G.GripSettings.Rotation.Z) end
})

GripGroup:AddSlider('GripRotZ', {
    Text = 'Z',
    Default = 0,
    Min = -180, Max = 180, Rounding = 1,
    Callback = function(val) G.GripSettings.Rotation = Vector3.new(G.GripSettings.Rotation.X, G.GripSettings.Rotation.Y, val) end
})

-- Reset button
GripGroup:AddLabel('Options:')
GripGroup:AddButton({
    Text = 'Reset',
    Func = function()
        G.GripSettings.Position = Vector3.new(0, 0, 0)
        G.GripSettings.Rotation = Vector3.new(0, 0, 0)
        -- Update UI sliders to match the reset values
        Options.GripPosX:SetValue(0)
        Options.GripPosY:SetValue(0)
        Options.GripPosZ:SetValue(0)
        Options.GripRotX:SetValue(0)
        Options.GripRotY:SetValue(0)
        Options.GripRotZ:SetValue(0)
    end,
    Tooltip = '>_<'
})



-- Main grip logic
local gripConnection
if gripConnection then gripConnection:Disconnect() end

gripConnection = S.RS.Stepped:Connect(function()
    if G.GripSettings.Enabled then
        local character = LP.Character
        local tool = character and character:FindFirstChildOfClass("Tool")
        if tool then
            -- Apply position only
            tool.GripPos = G.GripSettings.Position
            
            -- Apply rotation using proper CFrame
            local angles = CFrame.Angles(
                M.rad(G.GripSettings.Rotation.X),
                M.rad(G.GripSettings.Rotation.Y),
                M.rad(G.GripSettings.Rotation.Z)
            )
            
            -- Применяем правильно
            tool.Grip = CFrame.new(G.GripSettings.Position) * angles
        end
    end
end)

-- === BulletTP (Combat tab, новая секция) ===
local BulletTpGroup = Tabs.Combat:AddLeftGroupbox('>_<')

-- Инициализация настроек BulletTP
getgenv().BulletTp = {
    Enabled = false,
    Toggle = true,
    Keybind = Enum.KeyCode.C,
    Part = "Head",
    Selected = nil,
    UseAimbotTarget = true -- Всегда используем цель аимбота
}

-- UI для BulletTP
addToggleWithNotify(BulletTpGroup, 'BulletTpToggle', {
    Text = 'BulletTP',
    Default = false,
    Callback = function(v) 
        getgenv().BulletTp.Toggle = v 
    end,
    Tooltip = '>_<'
})

BulletTpGroup:AddLabel('BulletTP Key'):AddKeyPicker('BulletTpKey', {
    Default = 'C',
    Text = 'Key',
    NoUI = false,
    Callback = function(key)
        if typeof(key) == "EnumItem" then
            getgenv().BulletTp.Keybind = key
        elseif type(key) == "string" then
            getgenv().BulletTp.Keybind = Enum.KeyCode[key] or Enum.KeyCode.C
        end
    end
})

BulletTpGroup:AddDropdown('BulletTpPart', {
    Text = 'Part',
    Values = {'Head', 'HumanoidRootPart', 'Torso', 'UpperTorso', 'LowerTorso', 'Left Arm', 'Right Arm', 'Left Leg', 'Right Leg', 'LeftUpperArm', 'RightUpperArm', 'LeftUpperLeg', 'RightUpperLeg'},
    Default = 'Head',
    Callback = function(v) getgenv().BulletTp.Part = v end,
    Tooltip = '>_<'
})

-- Убрали тогл UseAimbot, т.к. BulletTP всегда работает с аимботом

-- Улучшенная функция поиска части тела
G.findBodyPart = function(character, partName)
    if not character then return nil end
    
    -- Прямой поиск по имени
    local part = character:FindFirstChild(partName)
    if part and part:IsA("BasePart") then return part end
    
    -- Мапинг альтернативных имен частей тела
    local partMap = {
        ["Torso"] = {"UpperTorso", "LowerTorso"},
        ["UpperTorso"] = {"Torso"},
        ["LowerTorso"] = {"Torso"},
        ["Left Arm"] = {"LeftUpperArm", "LeftLowerArm", "LeftHand"},
        ["Right Arm"] = {"RightUpperArm", "RightLowerArm", "RightHand"},
        ["Left Leg"] = {"LeftUpperLeg", "LeftLowerLeg", "LeftFoot"},
        ["Right Leg"] = {"RightUpperLeg", "RightLowerLeg", "RightFoot"},
        ["LeftUpperArm"] = {"Left Arm"},
        ["RightUpperArm"] = {"Right Arm"},
        ["LeftUpperLeg"] = {"Left Leg"},
        ["RightUpperLeg"] = {"Right Leg"}
    }
    
    -- Проверяем альтернативные названия
    if partMap[partName] then
        for _, altName in ipairs(partMap[partName]) do
            part = character:FindFirstChild(altName)
            if part and part:IsA("BasePart") then return part end
        end
    end
    
    -- Если не нашли, возвращаем HumanoidRootPart или Head как запасной вариант
    return character:FindFirstChild("HumanoidRootPart") or character:FindFirstChild("Head")
end

-- Функции BulletTP с защитой от ошибок
G.TeleportBullet = function(tool)
    local success, err = pcall(function()
        local BTP = getgenv().BulletTp
        if not BTP.Toggle or not BTP.Enabled then return end

        -- Всегда используем цель аимбота
        local target = getgenv().SilentAim and getgenv().SilentAim.currentTarget or BTP.Selected
        if not target or not target.Character then return end

        local originPart = LP.Character and LP.Character:FindFirstChild("RightHand")
        if not originPart then
            originPart = LP.Character and LP.Character:FindFirstChild("Right Arm")
        end
        if not originPart then return end
        
        local targetPart = G.findBodyPart(target.Character, BTP.Part)
        if not targetPart then return end

        if originPart and targetPart then
            local grip = tool.Grip
            tool.Parent = LP.Backpack
            tool.Grip = G.bulletTpCFOffset(originPart.CFrame, targetPart.CFrame)
            tool.Parent = LP.Character
            S.RS.RenderStepped:Wait()
            tool.Parent = LP.Backpack
            tool.Grip = grip
            tool.Parent = LP.Character
        end
    end)
    
    if not success and err then
        -- В режиме отладки можно логировать ошибки
        -- print("BulletTP error:", err)
    end
end

-- Переносим функцию в глобальную таблицу G с защитой от ошибок
G.HandleCharacter = function(character)
    local success, err = pcall(function()
        -- Очищаем предыдущие соединения
        for k, conn in pairs(G.bulletTpConns) do
            if k ~= "InputBegan" and k ~= "CharacterAdded" and k ~= "CharacterRemoving" and k ~= "TargetUpdate" then
                if typeof(conn) == "RBXScriptConnection" then conn:Disconnect() end
                G.bulletTpConns[k] = nil
            end
        end

        -- Обрабатываем инструменты при их добавлении
        G.bulletTpConns.CharacterChildAdded = character.ChildAdded:Connect(function(tool)
            if tool:IsA("Tool") then
                -- Отключаем стандартные обработчики изменения Grip
                for _, conn in ipairs(getconnections(tool:GetPropertyChangedSignal("Grip"))) do conn:Disable() end
                
                -- Создаем соединение с активацией инструмента
                if G.bulletTpConns.ToolActivated then
                    G.bulletTpConns.ToolActivated:Disconnect()
                end
                G.bulletTpConns.ToolActivated = tool.Activated:Connect(function() G.TeleportBullet(tool) end)
            end
        end)

        -- Обрабатываем удаление инструментов
        G.bulletTpConns.ChildRemovingCharacter = character.ChildRemoved:Connect(function(child)
            if child:IsA("Tool") and G.bulletTpConns.ToolActivated then
                G.bulletTpConns.ToolActivated:Disconnect()
                G.bulletTpConns.ToolActivated = nil
            end
        end)
        
        -- Проверяем, есть ли уже инструмент в руках
        local existingTool = character:FindFirstChildOfClass("Tool")
        if existingTool then
            for _, conn in ipairs(getconnections(existingTool:GetPropertyChangedSignal("Grip"))) do conn:Disable() end
            if G.bulletTpConns.ToolActivated then
                G.bulletTpConns.ToolActivated:Disconnect()
            end
            G.bulletTpConns.ToolActivated = existingTool.Activated:Connect(function() G.TeleportBullet(existingTool) end)
        end
    end)
    
    if not success and err then
        -- В режиме отладки можно логировать ошибки
        -- print("BulletTP HandleCharacter error:", err)
    end
end

-- Функция для выбора ближайшего игрока как цели BulletTP с защитой от ошибок
G.getClosestPlayer = function()
    local success, result = pcall(function()
        local closest, dist = nil, math.huge
        local myPos = LP.Character and LP.Character:FindFirstChild("HumanoidRootPart") and LP.Character.HumanoidRootPart.Position
        if not myPos then return nil end
        
        for _, p in ipairs(S.PS:GetPlayers()) do
            if p ~= LP and p.Character and p.Character:FindFirstChild("HumanoidRootPart") and 
               p.Character:FindFirstChildOfClass("Humanoid") and p.Character:FindFirstChildOfClass("Humanoid").Health > 0 then
                local d = (p.Character.HumanoidRootPart.Position - myPos).Magnitude
                if d < dist then closest, dist = p, d end
            end
        end
        return closest
    end)
    
    if success then
        return result
    else
        return nil
    end
end

-- Заменяем на глобальную функцию с защитой от ошибок
G.SetupBulletTp = function()
    local success, err = pcall(function()
        -- Очищаем все соединения
        for k, conn in pairs(G.bulletTpConns) do
            if typeof(conn) == "RBXScriptConnection" then conn:Disconnect() end
        end
        G.bulletTpConns = {}
        
        -- Настраиваем для текущего персонажа
        if LP.Character then
            G.HandleCharacter(LP.Character)
        end

        -- Соединение с событием добавления персонажа
        G.bulletTpConns.CharacterAdded = LP.CharacterAdded:Connect(function(newCharacter)
            task.wait(0.5) -- Ждем, чтобы персонаж полностью загрузился
            G.HandleCharacter(newCharacter)
        end)

        -- Соединение с событием удаления персонажа
        G.bulletTpConns.CharacterRemoving = LP.CharacterRemoving:Connect(function()
            -- Очищаем соединения, связанные с конкретным персонажем
            for k, conn in pairs(G.bulletTpConns) do
                if k ~= "InputBegan" and k ~= "CharacterAdded" and k ~= "CharacterRemoving" and k ~= "TargetUpdate" then
                    if typeof(conn) == "RBXScriptConnection" then conn:Disconnect() end
                    G.bulletTpConns[k] = nil
                end
            end
        end)
        
        -- Соединение с нажатием клавиш
        if not G.bulletTpConns.InputBegan then
            G.bulletTpConns.InputBegan = S.UIS.InputBegan:Connect(function(input, gpe)
                if gpe then return end
                
                if input.KeyCode == getgenv().BulletTp.Keybind then
                    -- Предотвращаем двойное срабатывание уведомлений
                    local wasEnabled = getgenv().BulletTp.Enabled
                    pcall(function()
                        getgenv().BulletTp.Enabled = not wasEnabled
                    end)
                    
                    G.targetName = "Нет цели"
                    if getgenv().SilentAim and getgenv().SilentAim.currentTarget then
                        G.targetName = getgenv().SilentAim.currentTarget.Name
                    elseif getgenv().BulletTp.Selected then
                        G.targetName = getgenv().BulletTp.Selected.Name
                    end
                    
                    -- Отправляем только одно уведомление
                    Library:Notify(">_< " .. (getgenv().BulletTp.Enabled and "on" or "off"), 2)
                end
            end)
        end
        
        -- Соединение с обновлением цели для запасного варианта
        if not G.bulletTpConns.TargetUpdate then
            G.bulletTpConns.TargetUpdate = HRT:Connect(function()
                -- Если нет цели аимбота, используем ближайшего игрока
                if not getgenv().SilentAim or not getgenv().SilentAim.currentTarget then
                    getgenv().BulletTp.Selected = G.getClosestPlayer()
                end
            end)
        end
    end)
    
    if not success and err then
        -- В режиме отладки можно логировать ошибки
        -- print("BulletTP Setup error:", err)
        
        -- Пробуем повторить установку через 5 секунд
        task.delay(5, G.SetupBulletTp)
    end
end

-- Запускаем BulletTP с защитой от ошибок
task.spawn(function()
    pcall(G.SetupBulletTp)
end)

-- Очистка соединений BulletTP при выходе из игры
S.PS.PlayerRemoving:Connect(function(player)
    if player == LP then
        pcall(function()
            for k, conn in pairs(G.bulletTpConns) do
                if typeof(conn) == "RBXScriptConnection" then conn:Disconnect() end
            end
            G.bulletTpConns = {}
        end)
    end
end)

-- === Save Distance (Combat tab, новая секция) ===
local SaveDistanceGroup = Tabs.Combat:AddRightGroupbox('>_<')

-- Настройки SaveDistance
getgenv().SaveDistance = {
    Enabled = false,
    OffsetX = 0,
    OffsetY = 100,
    OffsetZ = 0,
    Connection = nil,
    IsBuyingArmor = false,
    LastTarget = nil,
    DampingConnection = nil
}

-- UI для SaveDistance
SaveDistanceGroup:AddToggle('SaveDistanceEnabled', {
    Text = 'SavePos',
    Default = false,
    Callback = function(v) 
        getgenv().SaveDistance.Enabled = v
        toggleSaveDistance(v)
    end,
    Tooltip = '>_<'
})

SaveDistanceGroup:AddSlider('SaveDistanceOffsetX', {
    Text = 'X',
    Default = 0,
    Min = -200, Max = 200, Rounding = 0,
    Increment = 1,
    Callback = function(v) getgenv().SaveDistance.OffsetX = v end,
    Tooltip = '>_<'
})

SaveDistanceGroup:AddSlider('SaveDistanceOffsetY', {
    Text = 'Y',
    Default = 100,
    Min = -200, Max = 200, Rounding = 0,
    Increment = 1,
    Callback = function(v) getgenv().SaveDistance.OffsetY = v end,
    Tooltip = '>_<'
})

SaveDistanceGroup:AddSlider('SaveDistanceOffsetZ', {
    Text = 'Z',
    Default = 0,
    Min = -200, Max = 200, Rounding = 0,
    Increment = 1,
    Callback = function(v) getgenv().SaveDistance.OffsetZ = v end,
    Tooltip = '>_<'
})

-- Функция для получения "настоящей" позиции цели с учетом анти-аимбота
G.resolveCFrame = function(player)
    if not player or not player.Character then return nil end
    
    local success, result = pcall(function()
        local character = player.Character
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        local hrp = character:FindFirstChild("HumanoidRootPart")
        
        if not humanoid or not hrp then return nil end
        
        -- Базовые компоненты для расчета
        local velocity = hrp.Velocity
        local moveDirection = humanoid.MoveDirection
        local lookVector = hrp.CFrame.LookVector
        
        -- Проверяем передвижение
        local isMoving = velocity.Magnitude > 0.1
        local isPredictable = moveDirection.Magnitude > 0.1
        
        -- Если у цели есть явная скорость и направление движения
        if isMoving and isPredictable then
            -- Коррекция CFrame на основе направления движения и скорости
            local velocityUnit = velocity.Unit
            local dot = velocityUnit:Dot(lookVector)
            
            -- Если игрок движется примерно в направлении, куда смотрит (или в противоположном)
            if math.abs(dot) > 0.7 then
                -- Создаем новый CFrame, который учитывает реальное направление движения
                local forward = moveDirection.Unit
                local right = Vector3.new(forward.z, 0, -forward.x).Unit
                local up = Vector3.new(0, 1, 0)
                
                -- Сохраняем позицию, но корректируем ориентацию
                return CFrame.fromMatrix(hrp.Position, right, up, forward)
            end
        end
        
        -- Если не смогли определить лучше, возвращаем оригинальный CFrame
        return hrp.CFrame
    end)
    
    if success and result then
        return result
    else
        -- В случае ошибки возвращаем стандартный CFrame, если доступен
        return player.Character and player.Character:FindFirstChild("HumanoidRootPart") and 
               player.Character.HumanoidRootPart.CFrame
    end
end

-- Функция плавного затухания скорости
function smoothDamping(hrp, duration)
    -- Сначала отключаем предыдущее соединение на всякий случай
    if getgenv().SaveDistance.DampingConnection then
        getgenv().SaveDistance.DampingConnection:Disconnect()
        getgenv().SaveDistance.DampingConnection = nil
    end
    
    if not hrp then return end
    
    -- Сохраняем текущую скорость для плавного гашения
    local initialVelocity = hrp.Velocity
    local startTime = tick()
    
    -- Создаем соединение для плавного снижения скорости
    getgenv().SaveDistance.DampingConnection = game:GetService("RunService").Heartbeat:Connect(function()
        local elapsedTime = tick() - startTime
        local progress = math.min(elapsedTime / duration, 1) -- От 0 до 1
        
        if progress >= 1 then
            -- Когда время вышло, завершаем процесс
            hrp.Velocity = Vector3.new(0, -1, 0) -- Небольшая скорость вниз для естественного падения
            
            if getgenv().SaveDistance.DampingConnection then
                getgenv().SaveDistance.DampingConnection:Disconnect()
                getgenv().SaveDistance.DampingConnection = nil
            end
            return
        end
        
        -- Экспоненциальная функция затухания для более плавного эффекта
        local dampFactor = math.exp(-10 * progress)
        hrp.Velocity = initialVelocity * dampFactor
    end)
end

-- Функция для включения/отключения SaveDistance
function toggleSaveDistance(state)
    -- Отключаем предыдущее соединение SaveDistance
    if getgenv().SaveDistance.Connection then
        getgenv().SaveDistance.Connection:Disconnect()
        getgenv().SaveDistance.Connection = nil
        
        -- Плавно гасим скорость при отключении
        if not state and LP.Character and LP.Character:FindFirstChild("HumanoidRootPart") then
            smoothDamping(LP.Character.HumanoidRootPart, 0.8) -- 0.8 секунд на затухание скорости
        end
    end
    
    -- Отключаем предыдущее соединение затухания, если включаем SaveDistance
    if state and getgenv().SaveDistance.DampingConnection then
        getgenv().SaveDistance.DampingConnection:Disconnect()
        getgenv().SaveDistance.DampingConnection = nil
    end
    
    if state then
        getgenv().SaveDistance.Connection = HRT:Connect(function()
            -- Если в данный момент покупается броня, пропускаем обновление позиции
            if getgenv().SaveDistance.IsBuyingArmor then return end
            
            local target = getgenv().SilentAim and getgenv().SilentAim.currentTarget
            
            -- Если цель изменилась, плавно гасим скорость перед переходом к новой цели
            if target ~= getgenv().SaveDistance.LastTarget and getgenv().SaveDistance.LastTarget then
                -- Проверяем наличие локального персонажа
                if LP.Character and LP.Character:FindFirstChild("HumanoidRootPart") then
                    -- Плавное затухание перед переходом к новой цели
                    smoothDamping(LP.Character.HumanoidRootPart, 0.3) -- Меньше времени для смены цели
                end
            end
            
            -- Обновляем последнюю цель
            getgenv().SaveDistance.LastTarget = target
            
            if not target or not target.Character then return end
            
            -- Получаем реальный CFrame цели с учетом анти-аимбота
            local resolvedTargetCF = G.resolveCFrame(target)
            if not resolvedTargetCF then return end
            
            local character = LP.Character
            if not character then return end
            
            local hrp = character:FindFirstChild("HumanoidRootPart")
            if not hrp then return end
            
            -- Перемещаем игрока относительно цели с учетом всех осей
            local targetPos = resolvedTargetCF.Position
            local offset = Vector3.new(
                getgenv().SaveDistance.OffsetX,
                getgenv().SaveDistance.OffsetY,
                getgenv().SaveDistance.OffsetZ
            )
            
            -- Учитываем ориентацию цели для правильного смещения по X и Z
            -- Используем разрешенный CFrame для более точного расчета
            local offsetInWorldSpace = resolvedTargetCF.RightVector * offset.X + 
                                      Vector3.new(0, offset.Y, 0) + 
                                      resolvedTargetCF.LookVector * offset.Z
            
            local newPos = targetPos + offsetInWorldSpace
            hrp.CFrame = CFrame.new(newPos, targetPos) -- Смотрим на цель
        end)
        
        Library:Notify('>_< on', 3)
    else
        Library:Notify('>_< off', 3)
    end
end

-- === AutoArmor (Misc tab, new section) ===
-- Используем глобальную переменную вместо локальной
G.AutoArmorGroup = Tabs.Misc:AddLeftGroupbox('AutoArmor')

-- Глобальные настройки AutoArmor
G.AutoArmorSettings = {
    Enabled = false,
    LastArmorCheck = 0,
    CheckInterval = 1, -- Проверять каждую секунду
    MinArmorValue = 50, -- Покупать броню, когда значение меньше этого
    ArmorType = "[High-Medium Armor] - $2513", -- Тип брони для покупки
    Notify = true, -- Уведомлять о покупке брони
    DebugMode = false, -- Режим отладки для вывода значения брони
    -- Переменные для функции autoArmorFunction
    BuyingArmor = nil,
    IsBuying = false, -- Флаг, что в данный момент покупаем броню
    BuyingTimeout = 0, -- Время, когда закончится блокировка
    Connection = nil,
    char = nil,
    armorValue = 0,
    hrp = nil,
    armorShop = nil,
    armorItem = nil,
    originalCFrame = nil,
    originalVelocity = nil
}

-- Функция для определения текущего значения брони в зависимости от игры
G.getCurrentArmorValue = function()
    -- Для Da Hood: Character.BodyEffects.Armor
    G.char = LP.Character
    if G.char and G.char:FindFirstChild("BodyEffects") and G.char.BodyEffects:FindFirstChild("Armor") then
        return G.char.BodyEffects.Armor.Value
    end
    
    -- Для Del Hood: DataFolder.Information.Armor
    if LP:FindFirstChild("DataFolder") and 
       LP.DataFolder:FindFirstChild("Information") and 
       LP.DataFolder.Information:FindFirstChild("Armor") then
        return tonumber(LP.DataFolder.Information.Armor.Value) or 0
    end
    
    -- Если не нашли, пробуем другие возможные места
    G.possiblePaths = {
        {LP.Character, "Armor"},
        {LP, "Armor"},
        {LP, "stats", "Armor"},
        {LP, "Data", "Armor"},
        {LP, "PlayerData", "Armor"}
    }
    
    for _, path in ipairs(G.possiblePaths) do
        G.current = path[1]
        G.found = true
        
        for i = 2, #path do
            if G.current and G.current:FindFirstChild(path[i]) then
                G.current = G.current[path[i]]
            else
                G.found = false
                break
            end
        end
        
        if G.found and G.current and (typeof(G.current) == "number" or 
            (typeof(G.current) == "Instance" and G.current:IsA("NumberValue") or G.current:IsA("IntValue"))) then
            return typeof(G.current) == "number" and G.current or G.current.Value
        end
    end
    
    -- Если все методы не сработали, возвращаем 0
    return 0
end

-- Функция автоматической покупки брони
G.autoArmorFunction = function()
    -- Защита от ошибок
    G.success = pcall(function()
        if not G.AutoArmorSettings.Enabled then return end
        
        -- Проверяем, не покупаем ли уже броню
        G.now = tick()
        if G.AutoArmorSettings.IsBuying then
            -- Если процесс покупки длится слишком долго, сбрасываем флаг (защита от зависания)
            if G.now >= G.AutoArmorSettings.BuyingTimeout then
                G.AutoArmorSettings.IsBuying = false
                if getgenv().SaveDistance then
                    getgenv().SaveDistance.IsBuyingArmor = false
                end
                
                if G.AutoArmorSettings.Notify then
                    Library:Notify(">_<", 2)
                end
            else
                return -- Пропускаем выполнение, пока не завершится текущая покупка
            end
        end
        
        -- Проверяем не слишком часто для оптимизации
        if G.now - G.AutoArmorSettings.LastArmorCheck < G.AutoArmorSettings.CheckInterval then
            return
        end
        G.AutoArmorSettings.LastArmorCheck = G.now
        
        G.AutoArmorSettings.char = LP.Character
        if not G.AutoArmorSettings.char then return end
        
        -- Получаем текущее значение брони с учетом разных игр
        G.AutoArmorSettings.armorValue = G.getCurrentArmorValue()
        
        -- Если включен режим отладки, показываем текущее значение брони
        if G.AutoArmorSettings.DebugMode then
            print("Current armor value:", G.AutoArmorSettings.armorValue)
        end
        
        -- Если броня ниже минимального значения, покупаем новую
        if G.AutoArmorSettings.armorValue < G.AutoArmorSettings.MinArmorValue then
            -- Устанавливаем флаг, что сейчас покупаем броню
            G.AutoArmorSettings.IsBuying = true
            -- Устанавливаем таймаут в 3 секунды
            G.AutoArmorSettings.BuyingTimeout = G.now + 3
            
            -- Выполняем покупку в отдельном потоке, чтобы не блокировать основной цикл
            task.spawn(function()
                -- Сохраняем текущую позицию
                G.AutoArmorSettings.hrp = G.AutoArmorSettings.char:FindFirstChild("HumanoidRootPart")
                if not G.AutoArmorSettings.hrp then 
                    G.AutoArmorSettings.IsBuying = false
                    return 
                end
                
                G.AutoArmorSettings.BuyingArmor = G.AutoArmorSettings.hrp.CFrame
                
                -- Устанавливаем флаг, что покупаем броню (для SavePosition)
                if getgenv().SaveDistance and getgenv().SaveDistance.Enabled then
                    getgenv().SaveDistance.IsBuyingArmor = true
                end
                
                -- Ищем магазин брони
                G.AutoArmorSettings.armorShop = workspace:FindFirstChild("Ignored") and workspace.Ignored:FindFirstChild("Shop")
                if not G.AutoArmorSettings.armorShop then
                    -- Пробуем найти магазин в других местах
                    for _, folder in pairs(workspace:GetChildren()) do
                        if folder:FindFirstChild("Shop") then
                            G.AutoArmorSettings.armorShop = folder.Shop
                            break
                        end
                    end
                    
                    if not G.AutoArmorSettings.armorShop then 
                        -- Сбрасываем флаги покупки брони
                        if getgenv().SaveDistance then
                            getgenv().SaveDistance.IsBuyingArmor = false
                        end
                        G.AutoArmorSettings.IsBuying = false
                        return 
                    end
                end
                
                G.AutoArmorSettings.armorItem = G.AutoArmorSettings.armorShop:FindFirstChild(G.AutoArmorSettings.ArmorType)
                if not G.AutoArmorSettings.armorItem then
                    -- Если не нашли конкретный тип брони, ищем любую броню
                    for _, item in pairs(G.AutoArmorSettings.armorShop:GetChildren()) do
                        if item.Name:lower():find("armor") then
                            G.AutoArmorSettings.armorItem = item
                            break
                        end
                    end
                    
                    if not G.AutoArmorSettings.armorItem then 
                        -- Сбрасываем флаги покупки брони
                        if getgenv().SaveDistance then
                            getgenv().SaveDistance.IsBuyingArmor = false
                        end
                        G.AutoArmorSettings.IsBuying = false
                        return 
                    end
                end
                
                if not (G.AutoArmorSettings.armorItem:FindFirstChild("Head") and 
                       G.AutoArmorSettings.armorItem:FindFirstChild("ClickDetector")) then
                    -- Сбрасываем флаги покупки брони
                    if getgenv().SaveDistance then
                        getgenv().SaveDistance.IsBuyingArmor = false
                    end
                    G.AutoArmorSettings.IsBuying = false
                    return
                end
                
                -- Телепортируемся к броне, покупаем и возвращаемся
                G.AutoArmorSettings.originalCFrame = G.AutoArmorSettings.hrp.CFrame
                G.AutoArmorSettings.originalVelocity = G.AutoArmorSettings.hrp.Velocity
                
                -- Телепортируемся к броне
                G.AutoArmorSettings.hrp.CFrame = G.AutoArmorSettings.armorItem.Head.CFrame
                G.AutoArmorSettings.hrp.Velocity = Vector3.new(0, 0, 0) -- Сбрасываем скорость для стабильности
                
                -- Небольшая задержка перед покупкой
                task.wait(0.25)
                
                -- Покупаем броню
                fireclickdetector(G.AutoArmorSettings.armorItem.ClickDetector)
                
                -- Увеличиваем задержку перед возвращением
                task.wait(0.35)
                
                -- Проверяем, что HumanoidRootPart все еще существует перед возвратом
                if G.AutoArmorSettings.hrp and G.AutoArmorSettings.hrp.Parent then
                    -- Возвращаемся с несколькими попытками для надежности
                    for i = 1, 3 do
                        G.AutoArmorSettings.hrp.CFrame = G.AutoArmorSettings.originalCFrame
                        G.AutoArmorSettings.hrp.Velocity = G.AutoArmorSettings.originalVelocity -- Восстанавливаем скорость
                        task.wait(0.1) -- Ждем между попытками
                    end
                end
                
                -- Небольшая задержка для стабилизации
                task.wait(0.2)
                
                -- Сбрасываем флаги покупки брони
                if getgenv().SaveDistance then
                    getgenv().SaveDistance.IsBuyingArmor = false
                end
                G.AutoArmorSettings.IsBuying = false
                
                -- Уведомляем о покупке, если включены уведомления
                if G.AutoArmorSettings.Notify then
                    Library:Notify(">_<", 2)
                end
            end)
        else
            G.AutoArmorSettings.BuyingArmor = nil
        end
    end)
    
    if not G.success and G.AutoArmorSettings.Notify then
        -- Если произошла ошибка и включены уведомления, показываем сообщение об ошибке
        Library:Notify(">_<", 3)
        -- Сбрасываем флаги при ошибке
        G.AutoArmorSettings.IsBuying = false
        if getgenv().SaveDistance then
            getgenv().SaveDistance.IsBuyingArmor = false
        end
    end
end

-- Глобальная функция для включения/отключения AutoArmor
G.toggleAutoArmor = function(state)
    G.AutoArmorSettings.Enabled = state
    
    -- Отключаем предыдущее соединение
    if G.AutoArmorSettings.Connection then
        G.AutoArmorSettings.Connection:Disconnect()
        G.AutoArmorSettings.Connection = nil
    end
    
    -- Создаем новое соединение, если включено
    if state then
        G.AutoArmorSettings.Connection = game:GetService("RunService").RenderStepped:Connect(G.autoArmorFunction)
        
        -- Немедленно вызываем функцию для проверки текущего значения брони
        task.spawn(function()
            G.autoArmorFunction()
        end)
        
        Library:Notify(">_< on", 3)
    else
        Library:Notify(">_< off", 3)
    end
end

-- UI для AutoArmor
addToggleWithNotify(G.AutoArmorGroup, 'AutoArmorEnabled', {
    Text = 'AutoArmor',
    Default = false,
    Callback = function(v) 
        G.toggleAutoArmor(v)
    end,
    Tooltip = '>_<'
})

G.AutoArmorGroup:AddSlider('AutoArmorMinValue', {
    Text = 'MinValue',
    Default = G.AutoArmorSettings.MinArmorValue,
    Min = 0, Max = 200, Rounding = 0,
    Callback = function(v) G.AutoArmorSettings.MinArmorValue = v end,
    Tooltip = '>_<'
})

G.AutoArmorGroup:AddSlider('AutoArmorInterval', {
    Text = 'Interval',
    Default = G.AutoArmorSettings.CheckInterval,
    Min = 0.1, Max = 5, Rounding = 1,
    Callback = function(v) G.AutoArmorSettings.CheckInterval = v end,
    Tooltip = '>_<'
})

-- Упрощаем систему брони до двух основных вариантов
G.setupArmorOptions = function()
    -- Сначала определяем глобальные массивы и карты
    G.armorDropdownValues = {}
    G.armorValueMap = {}
    
    -- По умолчанию добавляем вариант для Da Hood
    G.daHoodOption = "[High-Medium Armor] (Da Hood)"
    table.insert(G.armorDropdownValues, G.daHoodOption)
    G.armorValueMap[G.daHoodOption] = "[High-Medium Armor] - $2513"
    
    -- Проверяем наличие магазина для Del Hood
    G.delHoodArmorFound = false
    if workspace:FindFirstChild("Ignored") and workspace.Ignored:FindFirstChild("Shop") then
        G.shop = workspace.Ignored.Shop
        -- Проверяем конкретный элемент для Del Hood (индекс 59)
        G.delHoodArmor = G.shop:GetChildren()[59]
        if G.delHoodArmor and G.delHoodArmor.Name:lower():find("armor") then
            G.delHoodOption = G.delHoodArmor.Name .. " (Del Hood)"
            table.insert(G.armorDropdownValues, G.delHoodOption)
            G.armorValueMap[G.delHoodOption] = G.delHoodArmor.Name
            G.delHoodArmorFound = true
        end
    end
    
    -- Если не нашли броню Del Hood по индексу, пробуем поискать по имени
    if not G.delHoodArmorFound then
        if workspace:FindFirstChild("Ignored") and workspace.Ignored:FindFirstChild("Shop") then
            for _, item in pairs(workspace.Ignored.Shop:GetChildren()) do
                if item.Name:lower():find("armor") and item.Name:lower():find("max") then
                    G.delHoodOption = item.Name .. " (Del Hood)"
                    table.insert(G.armorDropdownValues, G.delHoodOption)
                    G.armorValueMap[G.delHoodOption] = item.Name
                    G.delHoodArmorFound = true
                    break
                end
            end
        end
    end
end

-- Настраиваем опции брони
G.setupArmorOptions()

-- Сохраняем карту значений для использования в колбэке
G.AutoArmorSettings.ArmorValuesMap = G.armorValueMap

G.AutoArmorGroup:AddDropdown('AutoArmorType', {
    Text = 'ArmorType',
    Values = G.armorDropdownValues,
    Default = G.armorDropdownValues[1] or "",
    Callback = function(v) 
        -- Используем реальное имя предмета для поиска
        G.AutoArmorSettings.ArmorType = G.AutoArmorSettings.ArmorValuesMap[v] or v
    end,
    Tooltip = '>_<'
})

-- Конец скрипта

